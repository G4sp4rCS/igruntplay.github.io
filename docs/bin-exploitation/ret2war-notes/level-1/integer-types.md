# Apuntes sobre Tipos Enteros en C

## Introducción a los Tipos Enteros

En el lenguaje de programación C, los **tipos enteros** son fundamentales para almacenar números enteros. Estos tipos son esenciales en entornos de bajo nivel, como en la explotación de binarios, debido a sus propiedades específicas. A continuación, se exploran los tipos enteros sin signo (unsigned) y con signo (signed), sus límites, y los conceptos de overflow y underflow.

---

## Enteros sin Signo (Unsigned Integers)

Los **enteros sin signo** son el tipo más básico de entero en C y están diseñados para almacenar **solo números positivos**. Generalmente, ocupan **32 bits** (4 bytes) en la mayoría de los sistemas.

### Declaración
```c
unsigned int bar = 44;
```

### Impresión
- En base 10: Usa el especificador de formato `%u`.
- En base 16 (hexadecimal): Usa `0x%X`.

```c
printf("bar is %u\n", bar); // Imprime: bar is 44
```

---

## Enteros con Signo (Signed Integers)

Los **enteros con signo** pueden almacenar tanto **números positivos como negativos**. Esto reduce el rango de valores positivos que pueden representar en comparación con los enteros sin signo.

### Declaración
```c
int foo = -44;
```

### Impresión
- Usa el especificador de formato `%d` para mostrar el valor en base 10.

```c
printf("foo is %d\n", foo); // Imprime: foo is -44
```

---

## Límites de los Enteros sin Signo

Los enteros sin signo tienen un rango finito de valores. Por ejemplo, un entero sin signo de 32 bits puede almacenar valores desde **0** hasta **4294967295** (`0xFFFFFFFF` en hexadecimal). A continuación, se muestran los límites de algunos tipos comunes:

| Tipo         | Mínimo | Máximo               |
|--------------|--------|----------------------|
| uint8_t      | 0      | 255                  |
| uint16_t     | 0      | 65535                |
| uint32_t     | 0      | 4294967295          |
| uint64_t     | 0      | 18446744073709551615 |
| unsigned int | 0      | 4294967295          |

---

## Límites de los Enteros con Signo

Los enteros con signo de 32 bits tienen un rango que va desde **-2147483648** hasta **2147483647**. Esto se debe a que el bit más significativo se usa para indicar el signo del número, siguiendo el sistema de **complemento a dos**.

| Tipo    | Mínimo               | Máximo              |
|---------|----------------------|---------------------|
| int8_t  | -128                 | 127                 |
| int16_t | -32768               | 32767               |
| int32_t | -2147483648          | 2147483647         |
| int64_t | -9223372036854775808 | 9223372036854775807 |
| int     | -2147483648          | 2147483647         |

---

## Desbordamiento de Enteros (Overflow)

Cuando un entero **supera su valor máximo**, ocurre un **overflow**, y el valor se reinicia al **mínimo**. Por ejemplo, en un entero sin signo de 32 bits:

```
u32 es 4294967293 (0xFFFFFFFD), incrementando...
u32 es 4294967294 (0xFFFFFFFE), incrementando...
u32 es 4294967295 (0xFFFFFFFF), incrementando...
u32 es 0 (0x00000000), incrementando...
u32 es 1 (0x00000001), incrementando...
```

---

## Subdesbordamiento de Enteros (Underflow)

De manera similar, cuando un entero **disminuye por debajo de su valor mínimo**, ocurre un **underflow**, y el valor pasa al **máximo**. Por ejemplo, en un entero sin signo de 32 bits:

```
u32 es 3 (0x00000003), decrementando...
u32 es 2 (0x00000002), decrementando...
u32 es 1 (0x00000001), decrementando...
u32 es 0 (0x00000000), decrementando...
u32 es 4294967295 (0xFFFFFFFF), decrementando...
```

---

## Overflow y Underflow en Enteros con Signo

Los enteros con signo también experimentan overflow y underflow, pero el comportamiento es diferente debido al bit de signo. El umbral de overflow para un entero con signo de 32 bits ocurre en `0x7FFFFFFF`:

```
s32 es 2147483645 (0x7FFFFFFD), incrementando...
s32 es 2147483646 (0x7FFFFFFE), incrementando...
s32 es 2147483647 (0x7FFFFFFF), incrementando...
s32 es -2147483648 (0x80000000), incrementando...
s32 es -2147483647 (0x80000001), incrementando...
```
