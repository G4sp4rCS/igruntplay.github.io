# maxpsger's Easy crackme

- [Challenge page](https://crackmes.one/crackme/695b957ad7c572e88f5433f6)
- [Walkthrough by myself](https://youtu.be/_NDdCny_QrQ)

## 1) Runtime behavior

The binary prompts for a username and password, then prints either `false` or `congrats ??`. A successful input also launches a browser via `system("start <url>")`.

Example run (observed):

```
Enter username: hey
Enter password: hey
false
```

## 2) Initial fingerprinting

![Detect It Easy](Pasted%20image%2020260203142402.png)

FLIRT signatures resolve the standard iostream helpers and typical MSVC runtime routines (I/O, string routines, and allocator paths). This confirms we are mostly dealing with C++ STL usage rather than custom obfuscation.

## 3) Decompiler summary (what the program does)

The main logic reads two `std::string` values (username, password). It checks:

* `username.length() == 7` and `memcmp(username, "crackme", 7) == 0`
* `password.length() == 8` and `memcmp(password, "Rickroll", 8) == 0`

If both match, the program prints `congrats ??` and runs:

```
system("start https://youtu.be/dQw4w9WgXcQ?si=-WxzNHuzQt6O116t");
```

Otherwise, it prints `false`.

## 4) Key assembly patterns

### 4.1) `std::string` small‑string optimization (SSO)

The code compares a field against `0xF` to decide whether the string is stored inline or on heap. This matches MSVC’s `std::string` SSO layout (inline buffer size 15).

Representative sequence (schematic):

```asm
; if (capacity > 0xF) ptr = heap_ptr else ptr = &inline_buf
mov     rax, [rsp+cap]
cmp     rax, 0Fh
jbe     short use_inline
mov     rcx, [rsp+heap_ptr]
jmp     short have_ptr
use_inline:
lea     rcx, [rsp+inline_buf]
have_ptr:
```

This explains why the decompiler has checks like `if (guard > 0xF) v6 = Buf1[0];`.

### 4.2) Length checks before `memcmp`

You can see length checks such as `Size != 7` and `variable_inicializada_en_cero != 8` before calling `memcmp`. In assembly, that becomes a `cmp` and conditional jump to the failure path.

Representative sequence (schematic):

```asm
cmp     [rsp+username_len], 7
jne     fail
; rcx = username_ptr
; rdx = "crackme"
; r8d = 7
call    memcmp
test    eax, eax
jne     fail
```

### 4.3) Success vs failure paths

Once both comparisons pass, the success path prints a message and invokes `system("start ...")`. Otherwise, it prints `false`.

Representative sequence (schematic):

```asm
; success path
lea     rdx, congrats_str
call    std::operator<<
call    std::endl
lea     rcx, cmd_string
call    system
```

### 4.4) Destructor / free logic

At the end, the decompiler shows branches that call `free` only when the capacity exceeds 0xF. This is the typical `std::string` destructor path:

* If SSO is used, no heap free happens.
* If heap‑backed, free the allocation (with extra checks for small/large allocations).

The `__fastfail(5)` guard suggests MSVC’s debug/checked allocator metadata validation before free.

## 5) Reconstructed source code (C++, minimal and faithful)

This is a clean reconstruction of the original logic. It aims to be faithful to behavior, not exact formatting or library inlining.

```cpp
#include <iostream>
#include <string>
#include <cstring>
#include <cstdlib>

int main() {
    std::string user;
    std::string pass;

    std::cout << "Enter username: ";
    std::cin >> user;
    std::cout << "Enter password: ";
    std::cin >> pass;

    if (user.size() == 7 && std::memcmp(user.data(), "crackme", 7) == 0 &&
        pass.size() == 8 && std::memcmp(pass.data(), "Rickroll", 8) == 0) {
        std::cout << "congrats ??" << std::endl;
        std::system("start https://youtu.be/dQw4w9WgXcQ?si=-WxzNHuzQt6O116t");
    } else {
        std::cout << "false" << std::endl;
    }
    return 0;
}
```

## 6) Final input (flag)

```
Enter username: crackme
Enter password: Rickroll
congrats ??
```

## Key findings (grain of sand)

* The `0xF` capacity threshold strongly indicates MSVC `std::string` SSO usage.
* Both checks are strict length + `memcmp`, so no partial or prefix matches.
* The `system("start <url>")` call is the only side effect of a successful login.
* Failure path is a single print (`false`), no additional timing or anti‑debug logic observed.
* Heap frees are gated by capacity checks, matching `std::string` destructor behavior.
