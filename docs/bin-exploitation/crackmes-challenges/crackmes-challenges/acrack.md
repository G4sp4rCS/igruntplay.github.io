# ACrack — crackmes.one (easy) Write-up

## Context

Binary: `acrack.exe` (x64, MSVC/Mingw style)

## Initial clues

The program prints:

```
Mini crackme by @microsoftstorage writed on C!
Nickname:
```

That suggests a typical input → compare → branch flow. We confirm by inspecting `main`.

## Function of interest: `main`

### Screenshot

![Main](image.png)



#### Pseudocode (IDA decompile)

```c
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char *Str1_1;
  char *Str1;

  _main();
  printf("Mini crackme by @microsoftstorage writed on C!\n");
  printf("Nickname: ");
  scanf("%s[^\n]", Str1);
  if ( !strcmp(Str1, "CrackMeOne") )
  {
    printf("True!\n");
    printf("Password: ");
    scanf("%s[^\n]", Str1_1);
    if ( !strcmp(Str1_1, "t.me/Umno223") )
      printf("True!\n");
    else
      printf("Bad password, try again\n");
  }
  else
  {
    printf("bad nickname! try again\n");
  }
  return 0;
}
```

Observations:

- Two `scanf` calls collect `Nickname` and `Password`.
- Both inputs are validated by `strcmp` against hardcoded strings.
- This is a classic “two-step compare” crackme.

## IDA xgraph view

![IDA-PRO-GRAPH](image-1.png)




### Assembly (real IDA output)

Below are the core blocks from `main` (addresses are from IDA):

```assembly
main (.text @ 0x1400014f8):
1400014f8  push    rbp
1400014f9  mov     rbp, rsp
1400014fc  sub     rsp, 30h
140001500  call    __main

140001505  lea     rax, Format; "Mini crackme by @microsoftstorage write"...
14000150c  mov     rcx, rax; Format
14000150f  call    printf

140001514  lea     rax, aNickname; "Nickname: "
14000151b  mov     rcx, rax; Format
14000151e  call    printf

140001523  mov     rax, [rbp+Str1]
140001527  mov     rdx, rax
14000152a  lea     rax, aS; "%s[^\n]"
140001531  mov     rcx, rax; Format
140001534  call    scanf

140001539  mov     rax, [rbp+Str1]
14000153d  lea     rdx, Str2; "CrackMeOne"
140001544  mov     rcx, rax; Str1
140001547  call    strcmp
14000154c  test    eax, eax
14000154e  jnz     short loc_1400015BD

140001550  lea     rax, aTrue; "True!\n"
140001557  mov     rcx, rax; Format
14000155a  call    printf

14000155f  lea     rax, aPassword; "Password: "
140001566  mov     rcx, rax; Format
140001569  call    printf

14000156e  mov     rax, [rbp+var_10]
140001572  mov     rdx, rax
140001575  lea     rax, aS; "%s[^\n]"
14000157c  mov     rcx, rax; Format
14000157f  call    scanf

140001584  mov     rax, [rbp+var_10]
140001588  lea     rdx, aTMeUmno223; "t.me/Umno223"
14000158f  mov     rcx, rax; Str1
140001592  call    strcmp
140001597  test    eax, eax
140001599  jnz     short loc_1400015AC

14000159b  lea     rax, aTrue; "True!\n"
1400015a2  mov     rcx, rax; Format
1400015a5  call    printf
1400015aa  jmp     short loc_1400015CC

1400015ac  lea     rax, aBadPasswordTry; "Bad password, try again\n"
1400015b3  mov     rcx, rax; Format
1400015b6  call    printf
1400015bb  jmp     short loc_1400015CC

1400015bd  lea     rax, aBadNicknameTry; "bad nickname! try again\n"
1400015c4  mov     rcx, rax; Format
1400015c7  call    printf

1400015cc  mov     eax, 0
1400015d1  add     rsp, 30h
1400015d5  pop     rbp
1400015d6  retn
```

### Control flow explanation

1. `printf` prints the banner and the `Nickname:` prompt.
2. `scanf` reads user input into `Str1`.
3. `strcmp(Str1, "CrackMeOne")`:
   - If zero (equal), execution continues to the password branch.
   - If non‑zero, it jumps to the “bad nickname” message.
4. On success, `printf("True!")` and then asks for `Password`.
5. `scanf` reads the password into `Str1_1`.
6. `strcmp(Str1_1, "t.me/Umno223")`:
   - If zero, prints `True!`.
   - Else, prints `Bad password, try again`.

This is a textbook string-compare crackme: no hashing, no obfuscation, just direct `strcmp` against hardcoded constants.

## Reconstructed original C (cleaned)

Below is a cleaned reconstruction in standard C, matching the observed behavior.

```c
#include <stdio.h>
#include <string.h>

int main(void) {
    char nickname[128];
    char password[128];

    printf("Mini crackme by @microsoftstorage writed on C!\n");
    printf("Nickname: ");
    scanf("%127[^\n]", nickname);

    if (strcmp(nickname, "CrackMeOne") == 0) {
        printf("True!\n");
        printf("Password: ");
        scanf("%127[^\n]", password);

        if (strcmp(password, "t.me/Umno223") == 0) {
            printf("True!\n");
        } else {
            printf("Bad password, try again\n");
        }
    } else {
        printf("bad nickname! try again\n");
    }

    return 0;
}
```

Notes:

- The original binary likely uses stack pointers for input buffers; for safety, I used fixed-size arrays with width-limited `scanf`.
- The constant strings match the hardcoded values in the assembly.

## Validation

Expected correct inputs:

- Nickname: `CrackMeOne`
- Password: `t.me/Umno223`

This matches the runtime behavior shown in the console screenshots.

