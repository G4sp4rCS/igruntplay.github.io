# Constructores y Destructores (C++ Reversing)


## Repaso rápido: public / private / protected

- **private**: acceso solo desde miembros de la misma clase.
- **public**: acceso desde cualquier lugar.
- **protected**: como `private`, pero también accesible desde clases derivadas.

---

## Constructores: definición y reglas

**Definición:** función miembro especial que inicializa un objeto al momento de declararlo.

**Reglas clave:**
- Mismo nombre que la clase.
- Sin tipo de retorno.
- No se heredan.
- Deben ser públicos (si son privados/protegidos no tendría sentido usarlos desde fuera).

**Sintaxis general:**

```cpp
class Nombre {
public:
    Nombre(parametros) : init1(expr), init2(expr) {
        // cuerpo del constructor
    }
};
```

---


### Constructor básico + métodos `Lee` y `Guarda`

```cpp
#include <iostream>
using namespace std;

class pareja {
public:
    // Constructor
    pareja(int a2, int b2);
    // Funciones miembro
    void Lee(int &a2, int &b2);
    void Guarda(int a2, int b2);
private:
    // Datos miembro
    int a, b;
};

pareja::pareja(int a2, int b2) {
    a = a2;
    b = b2;
}

void pareja::Lee(int &a2, int &b2) {
    a2 = a;
    b2 = b;
}

void pareja::Guarda(int a2, int b2) {
    a = a2;
    b = b2;
}

int main() {
    pareja par1(12, 32);
    int x, y;

    par1.Lee(x, y);
    cout << "Valor de par1.a: " << x << endl;
    cout << "Valor de par1.b: " << y << endl;

    return 0;
}
```

---

## Constructor por defecto y el “most vexing parse”

**Declaraciones ilegales si existe constructor con parámetros:**

```cpp
pareja par1;    // ERROR si solo existe pareja(int,int)
pareja par1();  // ERROR: el compilador interpreta esto como prototipo de función
```

**Forma correcta al usar constructor por defecto:**

```cpp
pareja par2;    // Correcto: constructor sin parámetros
```

**Declaraciones válidas con argumentos:**

```cpp
pareja par1(12, 43);
pareja par2(45, 34);
```

---

## Inicialización de miembros (lista de inicialización)

La inicialización en la lista es preferible a asignar dentro del cuerpo:

```cpp
pareja::pareja(int a2, int b2) : a(a2), b(b2) {}
```

---

## Sobrecarga de constructores

Dos constructores con firmas distintas:

```cpp
class pareja {
public:
    pareja(int a2, int b2) : a(a2), b(b2) {}
    pareja() : a(0), b(0) {}
    void Lee(int &a2, int &b2);
    void Guarda(int a2, int b2);
private:
    int a, b;
};
```

---

## Argumentos por defecto

Con valores por defecto se evita sobrecargar:

```cpp
class pareja {
public:
    pareja(int a2 = 0, int b2 = 0) : a(a2), b(b2) {}
    void Lee(int &a2, int &b2);
    void Guarda(int a2, int b2);
private:
    int a, b;
};
```

---

## Asignación de objetos

```cpp
int main() {
    pareja par1(12, 32), par2;
    int x, y;

    par2 = par1;      // Copia de miembros (operador = por defecto)
    par2.Lee(x, y);

    cout << "Valor de par2.a: " << x << endl;
    cout << "Valor de par2.b: " << y << endl;
    return 0;
}
```

---

## Constructor copia

**Definición:**

```cpp
class pareja {
public:
    pareja(int a2 = 0, int b2 = 0) : a(a2), b(b2) {}
    pareja(const pareja &p); // Constructor copia
    void Lee(int &a2, int &b2);
    void Guarda(int a2, int b2);
private:
    int a, b;
};

pareja::pareja(const pareja &p) : a(p.a), b(p.b) {}
```

**Uso directo:**

```cpp
int main() {
    pareja par1(12, 32);
    pareja par2(par1); // Constructor copia
    int x, y;

    par2.Lee(x, y);
    cout << "Valor de par2.a: " << x << endl;
    cout << "Valor de par2.b: " << y << endl;
    return 0;
}
```

**Uso con inicialización por igualdad:**

```cpp
pareja par2 = par1; // También llama al constructor copia
```

**Caso curioso con conversión implícita:**

```cpp
pareja par2 = 14; // Se crea un temporal con pareja(14) y luego se copia
```

---

## Reversing: analisis del asm del video (MSVC x64)

### Convencion de llamada y shadow space

- **RCX** = primer argumento (en metodos: `this`).
- **RDX, R8, R9** = siguientes argumentos.
- **Shadow space**: 32 bytes reservados por el caller. MSVC "homea" los registros ahi:
  - `this$ = 8`, `a2$ = 16`, `b2$ = 24`

> En IDA muchas veces **no aparece `this`** en el prototipo, pero siempre viaja en RCX.
> En el callee, `RSP` apunta al return address, por eso el shadow space se ve desde `rsp+8`.

---

### Layout de la clase `pareja`

Dos `int` => **8 bytes**:

```
offset 0x00 -> a
offset 0x04 -> b
```

Se confirma por los accesos `[rax]` y `[rax+4]`.

**Idea clave:** como en structs, **solo los datos ocupan memoria**. Los metodos no suman bytes.

---

### Constructor: `pareja::pareja(int,int)`

```asm
this$ = 8
a2$   = 16
b2$   = 24
pareja::pareja(int,int) PROC
    mov     DWORD PTR [rsp+24], r8d   ; b2 (home)
    mov     DWORD PTR [rsp+16], edx   ; a2 (home)
    mov     QWORD PTR [rsp+8], rcx    ; this (home)

    mov     rax, QWORD PTR this$[rsp]
    mov     ecx, DWORD PTR a2$[rsp]
    mov     DWORD PTR [rax], ecx      ; this->a = a2

    mov     rax, QWORD PTR this$[rsp]
    mov     ecx, DWORD PTR b2$[rsp]
    mov     DWORD PTR [rax+4], ecx    ; this->b = b2

    mov     rax, QWORD PTR this$[rsp]
    ret     0
pareja::pareja(int,int) ENDP
```

**Puntos clave del instructor:**
- Primero guarda los argumentos en el shadow space y despues opera desde ahi.
- `this` es un puntero al objeto en stack.
- Aunque el constructor no retorna nada en C++, MSVC deja `this` en `RAX`.

---

### Metodo por referencia: `void pareja::Lee(int &, int &)`

```asm
this$ = 8
a2$   = 16
b2$   = 24
void pareja::Lee(int &,int &) PROC
    mov     QWORD PTR [rsp+24], r8    ; &b2 (home)
    mov     QWORD PTR [rsp+16], rdx   ; &a2 (home)
    mov     QWORD PTR [rsp+8], rcx    ; this (home)

    mov     rax, QWORD PTR a2$[rsp]   ; rax = &a2
    mov     rcx, QWORD PTR this$[rsp] ; rcx = this
    mov     ecx, DWORD PTR [rcx]      ; ecx = this->a
    mov     DWORD PTR [rax], ecx      ; *a2 = a

    mov     rax, QWORD PTR b2$[rsp]   ; rax = &b2
    mov     rcx, QWORD PTR this$[rsp]
    mov     ecx, DWORD PTR [rcx+4]    ; ecx = this->b
    mov     DWORD PTR [rax], ecx      ; *b2 = b
    ret     0
void pareja::Lee(int &,int &) ENDP
```

**Lectura rapida:**
- Como `a2` y `b2` son referencias, se pasan **punteros**.
- Por eso aparecen escrituras indirectas `mov [rax], ecx`.

---

### Metodo por valor: `void pareja::Guarda(int,int)`

```asm
void pareja::Guarda(int,int) PROC
    mov     DWORD PTR [rsp+24], r8d   ; b2 (home)
    mov     DWORD PTR [rsp+16], edx   ; a2 (home)
    mov     QWORD PTR [rsp+8], rcx    ; this (home)

    mov     rax, QWORD PTR this$[rsp]
    mov     ecx, DWORD PTR a2$[rsp]
    mov     DWORD PTR [rax], ecx      ; this->a = a2

    mov     rax, QWORD PTR this$[rsp]
    mov     ecx, DWORD PTR b2$[rsp]
    mov     DWORD PTR [rax+4], ecx    ; this->b = b2
    ret     0
void pareja::Guarda(int,int) ENDP
```

**Nota:** es practicamente igual al constructor, solo que se llama manualmente.

---

### `main`: stack, llamadas y strings

```asm
x$   = 32
y$   = 36
par1$= 40
main PROC
    sub     rsp, 56             ; 0x38
    mov     r8d, 32             ; b2
    mov     edx, 12             ; a2
    lea     rcx, QWORD PTR par1$[rsp] ; this = &par1
    call    pareja::pareja(int,int)

    lea     r8,  QWORD PTR y$[rsp]    ; &y
    lea     rdx, QWORD PTR x$[rsp]    ; &x
    lea     rcx, QWORD PTR par1$[rsp] ; this
    call    void pareja::Lee(int &,int &)
    ; ... cout << "Valor de par1.a: " << x << endl
    ; ... cout << "Valor de par1.b: " << y << endl
    add     rsp, 56
    ret     0
main ENDP
```

**Mapa rapido del stack en `main`:**

```
rsp+00h .. rsp+1Fh -> shadow space
rsp+20h           -> x (int)
rsp+24h           -> y (int)
rsp+28h           -> par1.a (int)
rsp+2Ch           -> par1.b (int)
```

**Strings y cout:**
- `$SG35296` = "Valor de par1.a: "
- `$SG35297` = "Valor de par1.b: "
- `std::operator<<` devuelve `cout` en `RAX` para encadenar `<<`.

**Nota de stack:** `sub rsp, 0x38` = `0x20` (shadow) + `0x18` (locals + padding/alineacion).

---

### Checklist rapido para identificar clases en asm

- `lea rcx, [rsp+X]` seguido de `call sub_xxx`: probable constructor.
- Accesos `[rcx]`, `[rcx+4]`, etc. revelan offsets de campos.
- Si ves `mov [rax], ecx` con `rax` cargado desde un argumento, es **referencia**.

---

### Apendice: Acceso a la información mediante punteros y ownership


**Objetivo:** comparar dos formas de "guardar" el estado leído del objeto:

- **Alias (non-owning):** punteros que apuntan a `x` e `y`. Si `x/y` cambian, el alias ve el cambio.
- **Ownership (owning copy):** `unique_ptr<int>` crea **copias en heap** de `x` e `y`. Si `x/y` cambian luego, la copia queda intacta.

**Idea clave:** el ownership no es sobre la variable original, sino sobre **memoria propia** reservada para guardar una copia.



```cpp
#include <iostream>
#include <memory>
using namespace std;

class pareja {
public:
    pareja(int a2, int b2);
    void Lee(int& a2, int& b2);
    void Guarda(int a2, int b2);
private:
    int a, b;
};

pareja::pareja(int a2, int b2) {
    a = a2;
    b = b2;
}

void pareja::Lee(int& a2, int& b2) {
    a2 = a;
    b2 = b;
}

void pareja::Guarda(int a2, int b2) {
    a = a2;
    b = b2;
}

int main() {
    pareja par1(12, 32);
    int x, y;

    // Leer valores desde el objeto
    par1.Lee(x, y);
    cout << "Valor de par1.a: " << x << endl;
    cout << "Valor de par1.b: " << y << endl;
    cout << "------------------------" << endl;

    // 1) Non-owning pointers (alias): apuntan a x e y
    int* px_alias = &x;
    int* py_alias = &y;
    cout << "Alias: *px_alias = " << *px_alias << ", *py_alias = " << *py_alias << endl;

    // 2) Owning pointers (preservan valores originales) con smart pointers
    auto px_saved = make_unique<int>(x);
    auto py_saved = make_unique<int>(y);
    cout << "Saved (smart pointers): *px_saved = " << *px_saved << ", *py_saved = " << *py_saved << endl;

    // Cambiamos los valores del objeto
    cout << "Guardando nuevos valores en par1..." << endl;
    par1.Guarda(45, 67);

    // Leemos de nuevo en x,y (estos cambian)
    par1.Lee(x, y);
    cout << "Nuevos valores de par1: " << x << ", " << y << endl;

    // Mostrar cómo se comportan las dos aproximaciones
    cout << "Alias después del cambio: *px_alias = " << *px_alias << ", *py_alias = " << *py_alias << endl;
    cout << "Saved (inmutable) después del cambio: *px_saved = " << *px_saved << ", *py_saved = " << *py_saved << endl;

    return 0;
}
```

### Relacion con reversing

- **Alias:** en asm veras solo **direcciones** que apuntan al stack (`lea rdx, [rsp+...]`).
- **Ownership:** apareceran llamadas a `operator new`/`delete` (o runtime) porque hay reserva en heap.
- Cuando el `unique_ptr` sale de scope, veras el cleanup al final de `main`.

---

### Decompilado IDA: `this` explicito y paso de parametros

En el decompilado de IDA, los metodos de C++ se ven como funciones normales con el
puntero `this` **explicito** como primer parametro:

```cpp
void __fastcall pareja::Lee(pareja *this, int *a2, int *b2)
{
  *a2 = this->a;
  *b2 = this->b;
}
```

**Claves:**

- El compilador **siempre pasa `this` como primer parametro** (en x64 MSVC va en `RCX`).
- IDA lo muestra como si fuera un argumento normal (`pareja *this`), aunque en C++
  no se escribe en el prototipo.
- Las referencias (`int&`) se ven como **punteros** (`int *`) porque a bajo nivel eso son.
- En `main`, las llamadas aparecen como `pareja::Lee(&par1, &x, &y)`: el primer
  argumento es `this` y los otros son los parametros reales.

**Con smart pointers:**

- En el decompilado aparecen `std::make_unique` y los destructores
  `std::unique_ptr<int>::~unique_ptr`, lo cual confirma la reserva y liberacion en heap.

---

## Destructores (adelanto del siguiente capítulo)

- El destructor tiene el mismo nombre de la clase con `~`.
- Se ejecuta cuando el objeto sale de ámbito.
