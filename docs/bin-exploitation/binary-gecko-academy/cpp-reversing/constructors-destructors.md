# Constructores y Destructores (C++ Reversing)


## Repaso rápido: public / private / protected

- **private**: acceso solo desde miembros de la misma clase.
- **public**: acceso desde cualquier lugar.
- **protected**: como `private`, pero también accesible desde clases derivadas.

---

## Constructores: definición y reglas

**Definición:** función miembro especial que inicializa un objeto al momento de declararlo.

**Reglas clave:**
- Mismo nombre que la clase.
- Sin tipo de retorno.
- No se heredan.
- Deben ser públicos (si son privados/protegidos no tendría sentido usarlos desde fuera).

**Sintaxis general:**

```cpp
class Nombre {
public:
    Nombre(parametros) : init1(expr), init2(expr) {
        // cuerpo del constructor
    }
};
```

---


### Constructor básico + métodos `Lee` y `Guarda`

```cpp
#include <iostream>
using namespace std;

class pareja {
public:
    // Constructor
    pareja(int a2, int b2);
    // Funciones miembro
    void Lee(int &a2, int &b2);
    void Guarda(int a2, int b2);
private:
    // Datos miembro
    int a, b;
};

pareja::pareja(int a2, int b2) {
    a = a2;
    b = b2;
}

void pareja::Lee(int &a2, int &b2) {
    a2 = a;
    b2 = b;
}

void pareja::Guarda(int a2, int b2) {
    a = a2;
    b = b2;
}

int main() {
    pareja par1(12, 32);
    int x, y;

    par1.Lee(x, y);
    cout << "Valor de par1.a: " << x << endl;
    cout << "Valor de par1.b: " << y << endl;

    return 0;
}
```

---

## Constructor por defecto y el “most vexing parse”

**Declaraciones ilegales si existe constructor con parámetros:**

```cpp
pareja par1;    // ERROR si solo existe pareja(int,int)
pareja par1();  // ERROR: el compilador interpreta esto como prototipo de función
```

**Forma correcta al usar constructor por defecto:**

```cpp
pareja par2;    // Correcto: constructor sin parámetros
```

**Declaraciones válidas con argumentos:**

```cpp
pareja par1(12, 43);
pareja par2(45, 34);
```

---

## Inicialización de miembros (lista de inicialización)

La inicialización en la lista es preferible a asignar dentro del cuerpo:

```cpp
pareja::pareja(int a2, int b2) : a(a2), b(b2) {}
```

---

## Sobrecarga de constructores

Dos constructores con firmas distintas:

```cpp
class pareja {
public:
    pareja(int a2, int b2) : a(a2), b(b2) {}
    pareja() : a(0), b(0) {}
    void Lee(int &a2, int &b2);
    void Guarda(int a2, int b2);
private:
    int a, b;
};
```

---

## Argumentos por defecto

Con valores por defecto se evita sobrecargar:

```cpp
class pareja {
public:
    pareja(int a2 = 0, int b2 = 0) : a(a2), b(b2) {}
    void Lee(int &a2, int &b2);
    void Guarda(int a2, int b2);
private:
    int a, b;
};
```

---

## Asignación de objetos

```cpp
int main() {
    pareja par1(12, 32), par2;
    int x, y;

    par2 = par1;      // Copia de miembros (operador = por defecto)
    par2.Lee(x, y);

    cout << "Valor de par2.a: " << x << endl;
    cout << "Valor de par2.b: " << y << endl;
    return 0;
}
```

---

## Constructor copia

**Definición:**

```cpp
class pareja {
public:
    pareja(int a2 = 0, int b2 = 0) : a(a2), b(b2) {}
    pareja(const pareja &p); // Constructor copia
    void Lee(int &a2, int &b2);
    void Guarda(int a2, int b2);
private:
    int a, b;
};

pareja::pareja(const pareja &p) : a(p.a), b(p.b) {}
```

**Uso directo:**

```cpp
int main() {
    pareja par1(12, 32);
    pareja par2(par1); // Constructor copia
    int x, y;

    par2.Lee(x, y);
    cout << "Valor de par2.a: " << x << endl;
    cout << "Valor de par2.b: " << y << endl;
    return 0;
}
```

**Uso con inicialización por igualdad:**

```cpp
pareja par2 = par1; // También llama al constructor copia
```

**Caso curioso con conversión implícita:**

```cpp
pareja par2 = 14; // Se crea un temporal con pareja(14) y luego se copia
```

---

## Reversing: cómo se ve en asm (Windows x64)

### Convención de llamada (MSVC x64)

- **RCX** = primer argumento entero/puntero (en métodos: `this`).
- **RDX, R8, R9** = siguientes argumentos.
- **Shadow space**: 32 bytes reservados por el caller.

> En C++ el puntero `this` viaja como primer parámetro implícito.

### Patrón típico: constructor con dos `int`

```asm
lea  rcx, [rsp+var_20]  ; RCX = &par1 (this)
mov  edx, 12            ; a2
mov  r8d, 32            ; b2
call pareja::pareja

; dentro del constructor
mov  [rcx], edx         ; this->a = a2
mov  [rcx+4], r8d       ; this->b = b2
```

### Referencias en asm (`Lee(int& a2, int& b2)`)

```asm
; RCX = this, RDX = &a2, R8 = &b2
mov  eax, [rcx]         ; cargar a
mov  [rdx], eax         ; *a2 = a
mov  eax, [rcx+4]       ; cargar b
mov  [r8], eax          ; *b2 = b
```

---

## Destructores (adelanto del siguiente capítulo)

- El destructor tiene el mismo nombre de la clase con `~`.
- Se ejecuta cuando el objeto sale de ámbito.

---

## Ejercicio propuesto (Sudoku)

Del cap. 29 se propone iniciar una estructura de clases para un Sudoku:

**Clase `Casilla`:**
- `valor` (char, 0-9)
- `posible` (9 bits de posibilidades)
- `opciones` (conteo de bits posibles)
- punteros: `sigFila`, `sigColumna`, `sigBloque`
- constructor con parámetro `char` (default 0) + getters/setters de punteros

**Clase `Tablero`:**
- array 9x9 de `Casilla`
- constructor vacío (todo en 0)
- constructor desde cadena de 81 chars (valores `1-9` o vacíos `.` `-` espacio)
- si la cadena es inválida => tablero vacío
- inicializar punteros `sigFila`, `sigColumna`, `sigBloque`
