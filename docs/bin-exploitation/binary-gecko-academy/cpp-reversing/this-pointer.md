# El puntero `this` (C++ Reversing)

## Idea principal

Cuando creas varios objetos de la misma clase, cada objeto tiene **sus propios datos** en memoria, pero los métodos se comparten.

Entonces surge la pregunta:

> Si todos usan el mismo método, ¿como sabe el metodo sobre que objeto trabajar?

La respuesta es el puntero `this`.

---

## Que es `this`

- `this` es un puntero al objeto actual.
- Existe en todos los metodos no-estaticos.
- En C++ fuente no lo ves casi nunca, pero el compilador lo pasa de forma implicita.

Ejemplo conceptual:

```cpp
obj.Asignar("hola");
```

A bajo nivel se interpreta como algo equivalente a:

```cpp
Asignar(&obj, "hola");
```

---

## Como se ve en reversing (MSVC x64)

Por eso en IDA, muchas veces veras que el decompilado del metodo muestra algo como:

```cpp
void __fastcall clase::Asignar(clase *this, const char *dest)
```

Aunque en tu codigo original escribiste:

```cpp
void clase::Asignar(const char *dest)
```

---

## Ejemplo simple: `EresTu`

```cpp
class Clase {
public:
    bool EresTu(Clase c) {
        return this == &c;
    }
};
```

- `this` apunta al objeto sobre el que se llama el metodo.
- `&c` apunta al parametro recibido.
- Si son la misma direccion: "si, soy yo".
- Si no: "no, no soy yo".

Uso:

```cpp
Clase c1, c2;
c1.EresTu(c2); // false
c1.EresTu(c1); // true
```

---

## Relacion con `struct` en C

En una `struct` con funciones externas no hay `this` automatico.
Si quieres el mismo comportamiento, debes pasar el puntero manualmente:

```c
void Asignar(struct Cadena *self, const char *dest);
```

En C++ eso te lo resuelve el compilador con `this`.
