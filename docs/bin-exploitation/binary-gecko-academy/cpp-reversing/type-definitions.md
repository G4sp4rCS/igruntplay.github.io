# Definición de Tipos con typedef en C++: Guía Completa de Reversing

## Índice

- [Introducción](#introducción)
- [Parte 1: ¿Qué es typedef?](#parte-1-qué-es-typedef)
- [Parte 2: Sintaxis Básica](#parte-2-sintaxis-básica)
- [Parte 3: typedef con Tipos Fundamentales](#parte-3-typedef-con-tipos-fundamentales)
- [Parte 4: typedef con Estructuras](#parte-4-typedef-con-estructuras)
- [Parte 5: typedef con Punteros a Funciones](#parte-5-typedef-con-punteros-a-funciones)
- [Parte 6: Análisis en Ensamblador](#parte-6-análisis-en-ensamblador)
- [Parte 7: Debugging y Análisis en IDA Pro](#parte-7-debugging-y-análisis-en-ida-pro)
- [Parte 8: Portabilidad y Dependencia de Plataforma](#parte-8-portabilidad-y-dependencia-de-plataforma)
- [Resumen: Lo Más Importante](#resumen-lo-más-importante)

---

## Introducción

El **typedef** es una palabra clave en C++ que permite **crear nombres alternativos (alias) para tipos de datos existentes**. Esta funcionalidad:

- **Mejora la legibilidad** del código
- **Facilita la portabilidad** entre plataformas
- **Simplifica la declaración** de tipos complejos (como punteros a funciones)
- **Reduce la duplicación** de código

**Objetivo:** Entender cómo typedef funciona internamente, cómo se ve en ensamblador y cómo reconocerlo en reverse engineering.

---

## Parte 1: ¿Qué es typedef?

### Concepto Fundamental

**typedef** es un **mecanismo de compilación** que crea un **alias para un tipo existente**. No crea un nuevo tipo en tiempo de ejecución, sino que es una **instrucción para el compilador** que dice: "usa este nuevo nombre como sinónimo para este tipo".

**Importante:** A nivel de ensamblador, `typedef` **desaparece completamente**. El compilador lo resuelve y usa el tipo original.

### Ejemplo Conceptual

```cpp
// Declaración original
unsigned int contador = 0;

// Con typedef
typedef unsigned int UINT;
UINT contador = 0;  // Exactamente lo mismo a nivel de compilación
```

En ambos casos, `contador` es un `unsigned int` de 4 bytes. La única diferencia es la **legibilidad**.

---

## Parte 2: Sintaxis Básica

### Forma General

```cpp
typedef <tipo_original> <nuevo_nombre>;
```

**Componentes:**

| Componente | Significado |
|---|---|
| `typedef` | Palabra clave |
| `<tipo_original>` | Cualquier tipo C++ (fundamental o derivado) |
| `<nuevo_nombre>` | El alias que queremos crear |

### Cosas Que Puedes Hacer con typedef

- Alias para tipos fundamentales
- Alias para estructuras
- Alias para uniones
- Alias para punteros
- Alias para **punteros a funciones** (lo más complejo)

---

## Parte 3: typedef con Tipos Fundamentales

### Ejemplos Comunes

```cpp
// Tipos sin signo
typedef unsigned int UINT;
typedef unsigned char BYTE;
typedef unsigned short int WORD;
typedef unsigned long int DWORD;

// Tipos con signo
typedef signed int INT;
typedef signed char CHAR;

// Enteros de tamaño fijo (modernamente se usan <cstdint>)
typedef unsigned int uint32_t;
typedef unsigned char uint8_t;
```

### Caso Práctico: WORD

```cpp
typedef unsigned short int WORD;

// Ahora podemos usar WORD en lugar de unsigned short int
WORD resultado = 1024;
```

**¿Por qué esto es útil?**

En algunas plataformas, una palabra (WORD) es de 16 bits, pero en otras puede ser diferente. Si defines WORD en un archivo de cabecera central, puedes cambiar fácilmente la definición según la plataforma:

```cpp
// En plataforma A (16 bits)
typedef unsigned short int WORD;

// En plataforma B (32 bits)
typedef unsigned int WORD;

// El resto del código no cambia
```

### A Nivel de Compilación

```cpp
typedef unsigned int UINT;
UINT a = 5;
```

El compilador **internamente reemplaza** `UINT` por `unsigned int`. A nivel de ensamblador:

```asm
mov dword ptr [rbp - 8], 5h    ; a es un DWORD (4 bytes)
```

---

## Parte 4: typedef con Estructuras

### Simplificación de Sintaxis

Sin typedef, para usar una estructura necesitas escribir la palabra `struct`:

```cpp
struct stpunto {
    int x;
    int y;
    int z;
};

// Declarar variable
stpunto p;  // ERROR: falta 'struct'
struct stpunto p;  // CORRECTO: necesitas 'struct'
```

Con typedef, puedes simplificar:

```cpp
typedef struct stpunto tipoPunto;

// Ahora puedes usar directamente
tipoPunto p;  // SIN necesidad de 'struct'
```

### Forma Compacta

También puedes definir el nombre del tipo **al mismo tiempo que la estructura**:

```cpp
typedef struct {
    int x;
    int y;
    int z;
} Punto3D;

// Declarar variable
Punto3D punto;  // Directo, sin 'struct'
```

En este caso, la **estructura no tiene nombre** (es anónima), pero el **tipo Punto3D** sí existe.

### Comparación

```cpp
// Forma clásica (sin typedef)
struct Punto3D {
    int x;
    int y;
    int z;
};
struct Punto3D p1;  // Necesitas 'struct'

// Forma con typedef
typedef struct {
    int x;
    int y;
    int z;
} Punto3D;
Punto3D p1;  // Directo
```

### A Nivel de Compilación

A nivel de ensamblador, ambas formas son **idénticas**. El compilador genera el mismo código para acceder a los miembros:

```cpp
typedef struct {
    int x;      // offset +0
    int y;      // offset +4
    int z;      // offset +8
} Punto3D;

Punto3D p;
p.x = 10;  // mov dword ptr [rbp - 12], 10 (p está 12 bytes abajo, x está en +0)
```

---

## Parte 5: typedef con Punteros a Funciones

### El Caso Más Complejo

Los **punteros a funciones** tienen una sintaxis complicada en C++. Aquí es donde typedef realmente brilla:

### Sin typedef (Confuso)

```cpp
// Puntero a función que retorna int y no toma argumentos
int (*pf)();

// Múltiples punteros
int (*pf1)();
int (*pf2)();
int (*pf3)();
```

**Problema:** La sintaxis `int (*pf)()` es confusa y repetitiva.

### Con typedef (Claro)

```cpp
// Define el tipo una vez
typedef int (*PFI)();

// Ahora crea variables fácilmente
PFI f1;
PFI f2;
PFI f3;
```

### Anatomía de la Sintaxis

```cpp
typedef int (*PFI)();
         |   |  |  |
         |   |  |  +-- Parámetros (vacío = sin parámetros)
         |   |  +------ Nombre del tipo (PFI)
         |   +---------- * indica que es un puntero
         +-------------- Tipo de retorno (int)
```

### Con Parámetros

```cpp
// Puntero a función que toma (int, float) y retorna double
typedef double (*CALC)(int, float);

CALC calculadora;
```

---

## Parte 6: Análisis en Ensamblador

### Ejemplo Completo

```cpp
typedef unsigned int UINT;

int main() {
    UINT a = 1;
    return 0;
}
```

**A nivel de ensamblador:**

```asm
main:
    push rbp
    mov rbp, rsp
    mov dword ptr [rbp - 4], 1h   ; a = 1, DWORD (4 bytes)
    xor eax, eax                   ; return 0
    pop rbp
    ret
```

**Observación:** `UINT` desaparece completamente. El compilador ve `unsigned int`, que es un `DWORD` (4 bytes).

### Ejemplo con Estructuras

```cpp
typedef struct {
    int x;
    int y;
    int z;
} Punto3D;

int main() {
    Punto3D p;
    p.x = 10;
    p.y = 20;
    p.z = 30;
}
```

**A nivel de ensamblador:**

```asm
main:
    push rbp
    mov rbp, rsp
    sub rsp, 12h              ; Reservar 12 bytes para p (3 ints)
    
    mov dword ptr [rbp - 12], 10h  ; p.x = 10 (offset +0)
    mov dword ptr [rbp - 8], 14h   ; p.y = 20 (offset +4)
    mov dword ptr [rbp - 4], 1eh   ; p.z = 30 (offset +8)
    
    xor eax, eax
    mov rsp, rbp
    pop rbp
    ret
```

**El nombre `Punto3D` desaparece.** Solo quedan los accesos a memoria con offsets.

---

## Parte 7: Debugging y Análisis en IDA Pro

### Reconocimiento de typedef

Cuando abres un programa compilado en **IDA Pro** o **x64dbg**, es difícil saber si un tipo fue creado con `typedef` porque:

1. **typedef desaparece en el binario** (es información del compilador)
2. Solo ves los **tipos subyacentes** en el código ensamblador
3. **Sin símbolos de debug**, es imposible conocer los nombres de typedef

### Debugging de Punteros a Funciones

Cuando encuentras un **call indirecto** (call a través de un puntero), puedes usar un truco en IDA Pro para anotar adónde va:

#### Truco 1: Ver la Dirección de la Función

```cpp
typedef int (*PFI)();
int miFunc() { return 2; }

int main() {
    PFI f = &miFunc;
    int result = f();
    return 0;
}
```

En ensamblador:

```asm
lea rax, miFunc      ; Cargar dirección de miFunc en rax
mov [rbp - 8], rax   ; Guardar en f
call qword ptr [rbp - 8]  ; Call indirecto a través de f
```

**En IDA Pro:**

1. **Ve a donde está la función** (ej: `miFunc` en `0x140001000`)
2. Haz clic derecho en `miFunc` → "Copy address" 
3. Ve al `call qword ptr [...]` → Haz clic derecho
4. **Edit** → **Change call address**
5. Pega la dirección con `0x` al inicio: `0x140001000`

Esto añade una **anotación** y permite hacer doble clic para navegar a la función.

#### Truco 2: Usar el Menú "Assemble"

```asm
call qword ptr [rbp - 8]
```

Si haces clic derecho → **Assemble**, ves la sintaxis clásica:

```asm
call qword ptr [rbp - 8]  ; call  qword ptr [rbp-8]
```

Esto te ayuda a **confirmar que es un puntero a función**.

### Debugging en Tiempo de Ejecución

```cpp
typedef int (*PFI)();
int miFunc() { return 2; }

PFI q = &miFunc;  // Global

int main() {
    int result = q();
    printf("%d", result);  // Imprime: 2
    return 0;
}
```

**En x64dbg o WinDbg:**

1. **Establece un breakpoint** en `q()`
2. Inspecciona `q` → Verás la dirección (ej: `0x140001000`)
3. Navega a esa dirección para ver el código de `miFunc`
4. Los **call registros** como `call rax` o `call qword ptr [...]` son indicios de **punteros a funciones**

---

## Parte 8: Portabilidad y Dependencia de Plataforma

### Problema: Tamaños Diferentes

En distintas plataformas, los tipos pueden tener **tamaños diferentes**:

```cpp
// Plataforma de 32 bits
sizeof(int) = 4 bytes
sizeof(long) = 4 bytes
sizeof(long long) = 8 bytes

// Plataforma de 64 bits
sizeof(int) = 4 bytes
sizeof(long) = 8 bytes  // DIFERENTE
sizeof(long long) = 8 bytes
```

### Solución: typedef Condicional

Si necesitas una palabra de **exactamente 16 bits** en **cualquier plataforma**, puedes usar typedef con condicionales:

```cpp
// En windows_types.h para plataforma Windows
#ifdef _WIN32
    typedef unsigned short int WORD;
#endif

// En unix_types.h para plataforma Unix
#ifdef __unix__
    typedef unsigned short int WORD;
#endif

// El resto del código no cambia
WORD valor = 1000;
```

O mejor aún, **usa los tipos estándar de C++11**:

```cpp
// En <cstdint> (moderno y recomendado)
typedef uint16_t WORD;
typedef uint32_t DWORD;
typedef uint8_t BYTE;
```

---

## Resumen: TL;DR

### ¿Qué es typedef?

- **Crea un alias** para un tipo existente
- **Desaparece en la compilación** (el compilador lo resuelve)
- **Mejora legibilidad** y **facilita portabilidad**

### Casos de Uso

| Caso | Ejemplo | Beneficio |
|---|---|---|
| Tipos fundamentales | `typedef unsigned int UINT;` | Portabilidad |
| Estructuras | `typedef struct { ... } Punto3D;` | No necesita `struct` |
| Punteros a funciones | `typedef int (*PFI)();` | Sintaxis clara |

### En Ensamblador

- **typedef desaparece completamente**
- Solo ves los tipos subyacentes
- Los offsets en memoria se calculan según los tipos originales

### En Debugging/Reversing

- **Sin símbolos de debug**, es difícil saber si un tipo tiene typedef
- Los **call indirectos** son indicio de **punteros a funciones**
- Usa **IDA Pro** para anotar direcciones y mejorar el análisis

### Lo Más Importante

**En reversing:**

```asm
mov dword ptr [rbp - 4], 5h       ; ¿Es UINT? ¿unsigned int? ¿int? 
                                   ; A nivel de asm, da lo mismo.

call qword ptr [rbp - 8]          ; Aquí hay un puntero a función.
                                   ; ¿Con typedef? Sin símbolo, no sabes.
```

El **tipo de dato (typedef o no) es irrelevante para la ejecución**, pero es **crucial para la comprensión humana** del código.
