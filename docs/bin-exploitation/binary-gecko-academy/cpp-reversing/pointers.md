# Punteros en C++: Guía Completa de Reversing

## Introducción

Los **punteros** son uno de los conceptos más importantes (y temidos) en C++. Sin embargo, son fundamentales para entender:

- Cómo se pasan estructuras grandes a funciones sin copiarlas completamente
- Cómo funcionan los arrays dinámicos
- Cómo se manipulan objetos complejos en ensamblador
- Cómo se realizan operaciones en memoria

**Objetivo:** Desmitificar los punteros y aprender a reconocerlos en ensamblador.

---

## Parte 1: Concepto Fundamental de Punteros

### ¿Qué es un Puntero?

Un **puntero** es una variable que **almacena la dirección de memoria de otra variable**.

**Conceptualmente:**

```
Variable normal:
    Nombre: a
    Valor: 5
    Dirección: 0x1000

Puntero a a:
    Nombre: pa
    Valor: 0x1000  (dirección de a)
    Dirección: 0x2000
```

**En el código:**

```cpp
int a = 5;           // Variable normal
int* pa = &a;        // Puntero a a (almacena dirección de a)
```

### Diferencia: Variable vs Puntero

| Característica | Variable Normal | Puntero |
|---|---|---|
| **Almacena** | Valor | Dirección de memoria |
| **Tamaño** | Depende del tipo (4, 8 bytes, etc.) | Siempre 8 bytes en x64 |
| **Declaración** | `int a;` | `int* pa;` |
| **Inicialización** | `a = 5;` | `pa = &a;` (operador &) |
| **Acceso al valor** | `a` | `*pa` (operador *) |

### Operadores Clave

#### Operador `&` (Dirección de - Address-of)

```cpp
int a = 5;
int* pa = &a;       // pa almacena la dirección de a
```

**En ensamblador:**

```asm
lea rax, [rsp+20]   ; Obtener dirección de a
mov [rsp+28], rax   ; Guardar en pa
```

**Nota:** `lea` (Load Effective Address) obtiene la dirección sin desreferenciar.

#### Operador `*` (Desreferenciación - Dereference)

```cpp
int a = 5;
int* pa = &a;
int b = *pa;        // b = 5 (obtener valor de a a través del puntero)
```

**En ensamblador:**

```asm
mov rax, [rsp+28]   ; RAX = dirección de a (valor de pa)
mov ebx, [rax]      ; EBX = valor en esa dirección (5)
```

**Nota:** `mov ebx, [rax]` desreferencia el puntero.

#### Operador `->` (Flecha - Arrow, para punteros a estructuras)

```cpp
struct Persona {
    int edad;
};

Persona p;
Persona* pp = &p;

p.edad = 30;        // Acceso directo
pp->edad = 30;      // Acceso a través de puntero (equivalente)
```

---

## Parte 2: Declaración y Tipado de Punteros

### Sintaxis de Declaración

```cpp
int* p_int;         // Puntero a int
char* p_char;       // Puntero a char
float* p_float;     // Puntero a float
Persona* p_persona; // Puntero a estructura Persona
```

**Nota:** El `*` está asociado al tipo, no a la variable:

```cpp
// Estos son equivalentes:
int* p1;
int *p1;

// Pero estos NO son equivalentes:
int* p1, p2;        // p1 es puntero, p2 es int (confuso)
int *p1, *p2;       // Ambos son punteros (más claro)
```

### Tipado de Punteros

**Un puntero solo puede apuntar a su tipo específico:**

```cpp
int a = 5;
char c = 'A';

int* p_int = &a;     // Correcto
int* p_int = &c;     // Error de compilación
int* p_int = (int*)&c; // Correcto (con cast)
```

**En reversing:** Si ves un puntero que apunta a un tipo incorrecto, probablemente hay:

- Un cast
- Un error del compilador
- Código intencional para eludir protecciones

### Puntero Nulo

```cpp
int* p = nullptr;   // Puntero sin dirección asignada
int* p = NULL;      // Equivalente (C++03)
int* p = 0;         // También equivalente
```

**En ensamblador:**

```asm
mov rax, 0          ; RAX = nullptr
mov [rsp+28], rax   ; p = nullptr
```

**Acceder a un puntero nulo causa crash:**

```cpp
int* p = nullptr;
int x = *p;         // Crash (Segmentation fault)
```

---

## Parte 3: Punteros en Ensamblador (x64 Windows)

### Asignación: Obtener Dirección

```cpp
int a = 5;
int* pa = &a;
```

**En ensamblador:**

```asm
lea rax, [rsp+20]   ; LEA = Load Effective Address
                    ; Obtiene la dirección de a sin desreferenciar
mov [rsp+28], rax   ; pa = dirección de a (8 bytes en x64)
```

**Notas clave:**

- `lea` obtiene la dirección (sin acceder a memoria)
- `mov [dirección], valor` almacena el valor en esa dirección

### Desreferenciación: Acceder al Valor

```cpp
int a = 5;
int* pa = &a;
int b = *pa;        // Leer valor de a a través de pa
*pa = 10;           // Escribir 10 en a a través de pa
```

#### ACLARACIÓN CRÍTICA: `*pa` vs `pa`

**Esta es la confusión más común. Veamos qué contiene cada cosa:**

**Memoria (ejemplo):**

```text
Dirección    Contenido              Variable
0x1000       5                      ← a (el valor)
0x2000       0x1000                 ← pa (la DIRECCIÓN de a)
0x3000       5                      ← b (el valor que asignamos)
```

**En el código:**

- `pa` contiene `0x1000` (la dirección de a)
- `*pa` accede a lo que hay EN esa dirección, que es `5` (el valor de a)
- `b = *pa` asigna el **valor** `5` a b, NO la dirección

**Comparación:**

```cpp
int b = pa;    // INCORRECTO: b sería 0x1000 (tipo incorrecto)
int b = *pa;   // CORRECTO: b es 5 (el valor)
```

**En ensamblador, verás la diferencia:**

```asm
; Si fuera int b = pa (INCORRECTO):
mov rax, [rsp+28]           ; RAX = 0x1000 (la dirección, valor de pa)
mov [rsp+24], rax           ; b = 0x1000 (la dirección)
; Problema: estamos asignando dirección a un int

; Correcto: int b = *pa
mov rax, [rsp+28]           ; RAX = 0x1000 (la dirección)
mov edx, [rax]              ; EDX = [0x1000] = 5 (DESREFERENCIA)
mov [rsp+24], edx           ; b = 5 (el valor)
```

**La clave del segundo `mov`:**

En `mov edx, [rax]`, los corchetes `[]` significan "accede a la dirección en RAX". Esto desreferencia el puntero.

Sin los corchetes sería diferente:

```asm
mov edx, rax                ; EDX = 0x1000 (la dirección)
mov edx, [rax]              ; EDX = 5 (el valor en esa dirección)
```

**Resumen con símbolos:**

| Operación | Significado | Valor |
|---|---|---|
| `pa` | El puntero mismo (contiene dirección) | `0x1000` |
| `*pa` | Lo que apunta el puntero | `5` |
| `&a` | La dirección de a | `0x1000` |

**Por eso `*pa` es equivalente a `&a` → ambos acceden al mismo lugar**

---

**Lectura:**

```asm
mov rax, [rsp+28]   ; RAX = dirección de a (valor de pa)
mov ebx, [rax]      ; EBX = valor en [RAX] (5)
```

**Escritura:**

```asm
mov rax, [rsp+28]   ; RAX = dirección de a
mov dword ptr [rax], 10 ; Escribir 10 en la dirección de a
```

### Operaciones Comunes

#### Lectura Simple

```cpp
int a = 5;
int* pa = &a;
int b = *pa;        // b = 5
```

```asm
mov rax, [rsp+28]       ; RAX = pa (dirección de a)
mov ebx, dword ptr [rax]; EBX = *pa (valor 5)
mov [rsp+32], ebx       ; b = 5
```

#### Asignación a través de Puntero

```cpp
int a = 5;
int* pa = &a;
*pa = 10;           // a ahora vale 10
```

```asm
mov rax, [rsp+28]           ; RAX = pa (dirección de a)
mov dword ptr [rax], 10     ; *pa = 10
```

#### Cadena de Lectura

```cpp
int a = 5;
int* pa = &a;
int b = *pa;        // b = 5
int c = b + 1;      // c = 6
```

```asm
mov rax, [rsp+28]           ; RAX = pa
mov ebx, dword ptr [rax]    ; EBX = *pa = 5
mov ecx, ebx                ; ECX = 5
add ecx, 1                  ; ECX = 6
mov [rsp+36], ecx           ; c = 6
```

---

## Parte 4: Ejemplo del Curso - Análisis Detallado

### Código Fuente

```cpp
#include <iostream>
using namespace std;

int main() {
    int a;              // Variable a (tipo int)
    int* pa = &a;       // Puntero pa que apunta a a
    
    *pa = 5;            // Asignar 5 a a a través del puntero
    int b = *pa;        // Leer valor de a a través del puntero
    *pa = 10;           // Asignar 10 a a a través del puntero
    
    cout << "a = " << a << ", b = " << b << endl;
    return 0;
}
```

**Valores finales:**

- `a = 10` (fue modificado a través de pa)
- `b = 5` (se asignó antes de que a cambiara a 10)

### Ensamblador Anotado (x64 Windows, con símbolos)

#### Prólogo

```asm
00401000: push    rbp
00401001: mov     rbp, rsp
00401004: sub     rsp, 40h        ; Reservar 64 bytes en el stack
00401008: mov     rax, fs:[28h]   ; Security Cookie
0040100F: mov     [rsp+38h], rax  ; Guardar cookie
```

**Stack layout:**

```text
RSP+0x00:  Shadow Space (32 bytes)
RSP+0x20:  a (int, 4 bytes)
RSP+0x24:  [padding, 4 bytes]
RSP+0x28:  pa (puntero, 8 bytes)
RSP+0x30:  [padding, 8 bytes]
RSP+0x38:  Security Cookie (8 bytes)
RSP+0x40:  RBP y return address
```

#### Asignación: pa = &a

```asm
00401018: lea     rax, [rsp+20h]  ; RAX = dirección de a
                                   ; [rsp+20h] es donde está a
                                   ; lea obtiene esta dirección
00401020: mov     [rsp+28h], rax   ; [rsp+28h] = pa
                                   ; pa ahora contiene dirección de a
```

**Resultado:**

```text
pa = 0x...RSP+0x20  (dirección de a)
a  = ? (aún no inicializado)
```

#### Lectura Simple de pa

```asm
00401024: mov     rax, [rsp+28h]  ; RAX = pa (dirección de a)
                                   ; RAX contiene la dirección
```

**Registro RAX después:**

```text
RAX = 0x...RSP+0x20 (la dirección de a)
```

#### Asignación a través del Puntero: *pa = 5

```asm
00401028: mov     dword ptr [rax], 5  ; Escribir 5 en [RAX]
                                       ; [RAX] = [dirección de a] = 5
```

**Resultado en memoria:**

```text
[RSP+0x20] = 5  (a ahora vale 5)
```

#### Lectura a través del Puntero: *pa

```asm
00401030: mov     rax, [rsp+28h]      ; RAX = pa (dirección de a)
00401034: mov     edx, [rax]          ; EDX = *pa = 5 (valor de a)
```

#### Asignación a b = *pa

```asm
00401036: mov     [rsp+24h], edx      ; [rsp+24h] = b
                                       ; b ahora vale 5
```

**Stack ahora:**

```text
[RSP+0x20] = 5      (a = 5)
[RSP+0x24] = 5      (b = 5)
[RSP+0x28] = dirección de a
```

#### Segunda Asignación: *pa = 10

```asm
0040103A: mov     rax, [rsp+28h]      ; RAX = pa (dirección de a)
00401040: mov     dword ptr [rax], 10 ; Escribir 10 en [RAX]
                                       ; a ahora vale 10
```

**Resultado:**

```text
[RSP+0x20] = 10     (a = 10)
[RSP+0x24] = 5      (b = 5, no cambió)
```

#### Impresión y Epilogo

```asm
00401044: lea     rcx, std::cout      ; RCX = &cout
00401050: lea     rdx, formato        ; RDX = "a = %d, b = %d"
00401057: call    std::operator<<     ; Imprimir

00401060: mov     ecx, 0              ; return 0
00401065: mov     rax, [rsp+38h]      ; Leer security cookie
0040106C: xor     rax, fs:[28h]       ; Verificar
00401074: call    __security_check_cookie
00401080: add     rsp, 40h            ; Liberar stack
00401087: pop     rbp
00401088: ret
```

### Visualización en Depuración

**Paso 1: Después de `lea rax, [rsp+20h]`**

```text
RAX = 0x1000000020  (dirección de a)
[RSP+0x28] = ???    (aún no asignado)
```

**Paso 2: Después de `mov [rsp+28h], rax`**

```text
RAX = 0x1000000020
[RSP+0x28] = 0x1000000020  (pa ahora apunta a a)
```

**Paso 3: Después de `mov dword ptr [rax], 5`**

```text
RAX = 0x1000000020  (dirección de a)
[RSP+0x20] = 5      (a ahora vale 5)
```

**Paso 4: Después de `mov edx, [rax]`**

```text
RAX = 0x1000000020  (dirección de a)
EDX = 5             (se leyó el valor de a)
```

**Paso 5: Después de `mov dword ptr [rax], 10`**

```text
RAX = 0x1000000020
[RSP+0x20] = 10     (a cambiado a 10)
[RSP+0x24] = 5      (b se mantuvo en 5)
```

---

## Parte 5: Punteros a Estructuras

### Declaración

```cpp
struct Persona {
    char nombre[65];
    char direccion[65];
    int anio_nacimiento;
};

Persona p;
Persona* pp = &p;       // Puntero a estructura
```

### Acceso a Campos

#### Método 1: Acceso Directo

```cpp
Persona p;
p.nombre[0] = 'J';
p.anio_nacimiento = 1990;
```

#### Método 2: Acceso a través de Puntero

```cpp
Persona p;
Persona* pp = &p;

pp->nombre[0] = 'J';           // Equivalente a p.nombre[0]
pp->anio_nacimiento = 1990;    // Equivalente a p.anio_nacimiento
```

### En Ensamblador

```asm
; pp = &p
lea rax, [rsp+28]           ; RAX = dirección de p
mov [rsp+120], rax          ; pp = RAX

; pp->anio_nacimiento = 1990
mov rax, [rsp+120]          ; RAX = pp (dirección de p)
add rax, 130                ; RAX += offset de anio_nacimiento
mov dword ptr [rax], 1990   ; Escribir 1990

; int edad = pp->anio_nacimiento
mov rax, [rsp+120]          ; RAX = pp
add rax, 130                ; RAX += offset
mov edx, [rax]              ; EDX = *[RAX]
mov [rsp+64], edx           ; edad = EDX
```

---

## Parte 6: Punteros y Funciones

### Pasar Puntero a Función

```cpp
void modificar(int* ptr) {
    *ptr = 20;              // Modifica el valor al que apunta
}

int main() {
    int a = 10;
    modificar(&a);          // Pasar puntero a a
    cout << a << endl;      // Imprime 20
}
```

**Ventaja:** No se copia el valor, solo se pasa la dirección (8 bytes).

### En Ensamblador

#### Llamada a la función

```asm
lea rax, [rsp+20]           ; RAX = &a
mov rcx, rax                ; RCX = puntero (primer parámetro)
call modificar              ; Llamar
```

**x64 FastCall:** El primer parámetro va en `RCX`.

#### Dentro de modificar()

```asm
modificar proc near:
    mov rcx, [rbp+16]       ; RCX = puntero pasado
    mov dword ptr [rcx], 20 ; *ptr = 20
    ret
```

### Caso de Uso: Estructuras Grandes

```cpp
struct DatosGrandes {
    char datos[8000];       // 8 KB
};

void procesar(DatosGrandes* pdatos) {  // Pasar puntero (8 bytes)
    pdatos->datos[0] = 'A';
}

int main() {
    DatosGrandes d;
    procesar(&d);           // Pasar puntero, no copiar 8 KB
}
```

**Sin punteros:** Sería necesario copiar 8000 bytes en el stack.  
**Con punteros:** Solo se copia una dirección (8 bytes).

---

## Parte 7: Aritmética de Punteros

### Suma y Resta de Punteros

```cpp
int arr[10];
int* p = arr;   // p apunta al primer elemento

p++;            // p ahora apunta al segundo elemento
p += 5;         // p ahora apunta al sexto elemento
p--;            // p ahora apunta al quinto elemento
```

**En memoria:**

```text
arr[0]  en 0x1000
arr[1]  en 0x1004  (0x1000 + 4)
arr[2]  en 0x1008  (0x1000 + 8)
arr[5]  en 0x1014  (0x1000 + 20)

p = 0x1000
p++     => p = 0x1004  (suma el tamaño del tipo: 4 bytes para int)
p += 5  => p = 0x1014  (suma 5 * 4 = 20 bytes)
```

**En ensamblador:**

```asm
lea rax, arr            ; RAX = dirección de arr[0]
mov rcx, 1
add rax, rcx            ; Esto suma 1 byte, INCORRECTO

; Correcto:
lea rax, arr
mov rcx, 1
imul rcx, 4             ; Multiplicar offset por tamaño de int
add rax, rcx            ; Ahora apunta a arr[1]

; O más directo:
lea rax, arr
add rax, 4              ; Sumar directamente 4 bytes = arr[1]
```

### Diferencia de Punteros

```cpp
int* p1 = &arr[2];
int* p2 = &arr[5];

int distancia = p2 - p1;    // distancia = 3
```

**En ensamblador:**

```asm
lea rax, [arr+8]            ; p1 = &arr[2]
lea rbx, [arr+20]           ; p2 = &arr[5]

mov rcx, rbx
sub rcx, rax                ; RCX = p2 - p1 = 12 bytes
sar rcx, 2                  ; Dividir por 4 (tamaño de int)
; RCX = 3 (elementos)
```

---

## Parte 8: Puntero a Puntero (double pointer)

### Concepto

```cpp
int a = 5;
int* pa = &a;       // Puntero a int
int** ppa = &pa;    // Puntero a puntero a int
```

**Estructura de memoria:**

```text
a       en 0x1000, valor = 5
pa      en 0x2000, valor = 0x1000 (dirección de a)
ppa     en 0x3000, valor = 0x2000 (dirección de pa)
```

### Desreferenciación

```cpp
int x = **ppa;      // x = 5
                    // *ppa = pa (dirección de a)
                    // **ppa = *pa = a = 5
```

**En ensamblador:**

```asm
mov rax, [rsp+40]   ; RAX = ppa (dirección de pa)
mov rax, [rax]      ; RAX = pa (dirección de a)
mov eax, [rax]      ; EAX = a (valor 5)
```

### Asignación

```cpp
**ppa = 10;         // Asignar 10 a a a través de ppa
```

**En ensamblador:**

```asm
mov rax, [rsp+40]           ; RAX = ppa
mov rax, [rax]              ; RAX = pa
mov dword ptr [rax], 10     ; *pa = 10
```

---

## Parte 9: Punteros y Arrays

### Array como Puntero

```cpp
int arr[10] = {1, 2, 3, 4, 5};
int* p = arr;       // p apunta al primer elemento

cout << p[0] << endl;   // 1
cout << p[1] << endl;   // 2
cout << *(p+2) << endl; // 3
```

**En ensamblador:**

```asm
lea rax, arr            ; RAX = dirección de arr[0]

mov edx, [rax]          ; p[0] = EDX = 1
mov edx, [rax+4]        ; p[1] = EDX = 2
mov edx, [rax+8]        ; p[2] = EDX = 3
```

### Iteración con Punteros

```cpp
int arr[5] = {10, 20, 30, 40, 50};

for (int* p = arr; p < arr + 5; p++) {
    cout << *p << endl;
}
```

**En ensamblador:**

```asm
lea rax, arr                ; p = arr
lea rbx, [arr+20]           ; rbx = arr + 5 (5 elementos * 4 bytes)

loop_start:
    cmp rax, rbx            ; if (p < arr+5)
    jge loop_end
    
    mov edx, [rax]          ; EDX = *p
    ; ... usar EDX ...
    
    add rax, 4              ; p++ (siguiente elemento)
    jmp loop_start
    
loop_end:
```

---

## Parte 10: Reconocimiento de Punteros en IDA Pro (Sin Símbolos)

### Patrón 1: LEA + MOV (Asignación de Puntero)

```asm
lea rax, [rsp+20]       ; Obtener dirección
mov [rsp+28], rax       ; Guardar en variable (puntero)
```

**Indicador:** `lea` seguido de `mov` → Probablemente asignación de puntero.

### Patrón 2: MOV Doble (Desreferenciación)

```asm
mov rax, [rsp+28]       ; Cargar puntero
mov edx, [rax]          ; Desreferenciar puntero
```

**Indicador:** Dos `mov` sucesivos → Probablemente lectura a través de puntero.

### Patrón 3: Escritura a través de Puntero

```asm
mov rax, [rsp+28]           ; Cargar puntero
mov dword ptr [rax], 10     ; Escribir a través de puntero
```

**Indicador:** `mov dword ptr [registro], valor` → Escritura desreferenciada.

### Patrón 4: Puntero a Estructura

```asm
lea rax, [rsp+28]           ; RAX = dirección de estructura
mov [rsp+80], rax           ; Guardar puntero

mov rax, [rsp+80]           ; Cargar puntero
mov edx, [rax+82]           ; Leer campo en offset 82
```

**Indicador:** Offsets dentro de desreferenciación → Puntero a estructura.

### Patrón 5: Llamada a Función con Puntero

```asm
lea rax, [rsp+28]           ; RAX = &variable
mov rcx, rax                ; RCX = puntero (primer parámetro)
call sub_401234             ; Pasar puntero a función
```

**Indicador:** `lea`, luego `mov rcx`, luego `call` → Pasar puntero como parámetro.

---

## Parte 11: Importancia de Punteros en Reversing

### ¿Por Qué Son Críticos?

**1. Estructuras Grandes**

```cpp
struct MuchisDatos {
    char buffer[8000];
};

void procesar(MuchisDatos* p) {
    p->buffer[0] = 'X';
}
```

Sin punteros, sería imposible pasar 8000 bytes eficientemente.

**2. Modificación In-Place**

```cpp
void incrementar(int* ptr) {
    (*ptr)++;
}

int x = 10;
incrementar(&x);    // x ahora vale 11
```

El puntero permite modificar la variable original.

**3. Arrays Dinámicos**

```cpp
int* arr = new int[1000];
arr[0] = 100;
arr[999] = 200;
```

Los arrays dinámicos se manejan completamente con punteros.

**4. Listas Enlazadas, Árboles, etc.**

```cpp
struct Nodo {
    int dato;
    Nodo* siguiente;  // Puntero al siguiente nodo
};
```

Las estructuras recursivas requieren punteros.

### En Reversing

Cuando ves punteros en ensamblador:

- Hay transferencia de estructuras entre funciones
- Hay modificación de datos desde otra función
- Hay operaciones complejas (búsquedas, iteraciones)
- El tamaño de datos es significativo

---

## Parte 12: Stack Frame con Punteros

### Ejemplo Completo

```cpp
int main() {
    int a = 100;
    int b = 200;
    int* pa = &a;
    int* pb = &b;
    
    *pa = 500;
    *pb = 600;
}
```

### Stack Layout

```text
RSP+0x00:  Shadow Space (32 bytes)
RSP+0x20:  a (int, 4 bytes) = 100 → 500
RSP+0x24:  b (int, 4 bytes) = 200 → 600
RSP+0x28:  pa (puntero, 8 bytes) = &a
RSP+0x30:  pb (puntero, 8 bytes) = &b
RSP+0x38:  Security Cookie (8 bytes)
```

### Ensamblador Completo

```asm
; a = 100
mov dword ptr [rsp+20], 100

; b = 200
mov dword ptr [rsp+24], 200

; pa = &a
lea rax, [rsp+20]
mov [rsp+28], rax

; pb = &b
lea rax, [rsp+24]
mov [rsp+30], rax

; *pa = 500
mov rax, [rsp+28]           ; RAX = pa
mov dword ptr [rax], 500    ; a ahora vale 500

; *pb = 600
mov rax, [rsp+30]           ; RAX = pb
mov dword ptr [rax], 600    ; b ahora vale 600
```

### Estado Final

```text
[RSP+0x20] = 500  (a)
[RSP+0x24] = 600  (b)
```

---

## Parte 13: Errores Comunes con Punteros

### Error 1: Usar Puntero Nulo

```cpp
int* p = nullptr;
int x = *p;         // Crash!
```

**En reversing:** Si ves `mov eax, [0]` o similar → Probablemente crash intencional o bug.

### Error 2: Puntero a Variable Local

```cpp
int* puntero_global;

void funcion() {
    int a = 5;
    puntero_global = &a;    // ¡Peligro! a se destruye al salir
}

int main() {
    funcion();
    int x = *puntero_global;  // Crash o valor basura
}
```

**En reversing:** Punteros que apuntan a stack de funciones ya terminadas → Bug.

### Error 3: Confundir Dirección con Valor

```cpp
int a = 100;
int* p = &a;
cout << p << endl;      // Imprime dirección (0x1000)
cout << *p << endl;     // Imprime valor (100)
```

### Error 4: Olvidar Desreferenciar

```cpp
int a = 100;
int* p = &a;

int b = p;      // Asigna dirección a int (error de tipos)
int c = *p;     // Correcto: asigna valor
```

---

## Checklist: Reconocer Punteros en Ensamblador

Cuando revises una función desconocida:

- [ ] ¿Hay `lea` seguido de `mov` en el stack? → Puntero asignado
- [ ] ¿Hay `mov` doble sobre el mismo registro? → Posible desreferenciación
- [ ] ¿Hay `mov dword ptr [registro], valor`? → Escritura desreferenciada
- [ ] ¿Hay offsets dentro de desreferenciación? → Puntero a estructura
- [ ] ¿Se pasan registros a funciones con `lea` antes? → Puntero como parámetro
- [ ] ¿Hay operaciones de suma en punteros? → Aritmética de punteros (arrays)

---

## Parte 14: Comparación Directa con Ensamblador del Video

### Código Original (del video)

```cpp
int main() {
    int a;
    int* pa = &a;
    *pa = 5;
    int b = *pa;
    *pa = 10;
    return 0;
}
```

### Ensamblador Esperado (sin optimizaciones)

```asm
00401000: push    rbp
00401001: mov     rbp, rsp
00401004: sub     rsp, 40h

; pa = &a
00401008: lea     rax, [rsp+20h]      ; Obtener dirección de a
00401010: mov     [rsp+28h], rax      ; pa = dirección

; *pa = 5
00401018: mov     rax, [rsp+28h]      ; Cargar pa
0040101C: mov     dword ptr [rax], 5  ; Escribir 5

; b = *pa
00401024: mov     rax, [rsp+28h]      ; Cargar pa
00401028: mov     edx, [rax]          ; Leer valor (5)
0040102C: mov     [rsp+24h], edx      ; b = 5

; *pa = 10
00401030: mov     rax, [rsp+28h]      ; Cargar pa
00401034: mov     dword ptr [rax], 10 ; Escribir 10

; Epilogo
00401038: xor     eax, eax            ; return 0
0040103A: add     rsp, 40h
00401041: pop     rbp
00401042: ret
```

### Análisis Paso a Paso en Depuración

| Instrucción | RAX | [RSP+20] (a) | [RSP+28] (pa) | [RSP+24] (b) |
|---|---|---|---|---|
| Inicial | - | ? | - | - |
| `lea rax, [rsp+20]` | 0x...0x20 | ? | - | - |
| `mov [rsp+28], rax` | 0x...0x20 | ? | 0x...0x20 | - |
| `mov rax, [rsp+28]` | 0x...0x20 | ? | 0x...0x20 | - |
| `mov [rax], 5` | 0x...0x20 | 5 | 0x...0x20 | - |
| `mov rax, [rsp+28]` | 0x...0x20 | 5 | 0x...0x20 | - |
| `mov edx, [rax]` | 0x...0x20 | 5 | 0x...0x20 | - |
| `mov [rsp+24], edx` | 0x...0x20 | 5 | 0x...0x20 | 5 |
| `mov rax, [rsp+28]` | 0x...0x20 | 5 | 0x...0x20 | 5 |
| `mov [rax], 10` | 0x...0x20 | 10 | 0x...0x20 | 5 |

---

## Resumen: Lo Más Importante

### Conceptos Clave

1. **Puntero = Dirección de memoria**
   - Se obtiene con `&variable`
   - Se desreferencia con `*puntero`

2. **En ensamblador:**
   - `lea` obtiene dirección (sin desreferenciar)
   - `mov` carga/almacena direcciones o valores
   - `[registro]` desreferencia el puntero

3. **Ventajas principales:**
   - Pasar estructuras grandes sin copiarlas
   - Modificar variables desde otra función
   - Manejar arrays y estructuras dinámicas

4. **Patrones a reconocer:**
   - `lea + mov` = asignación de puntero
   - `mov + mov` = desreferenciación
   - `mov dword ptr [reg], val` = escritura desreferenciada

### Para Reversing

- Los punteros son **fundamentales** para pasar datos entre funciones
- Sin punteros, es imposible trabajar con estructuras grandes
- La aritmética de punteros implica multiplicación por el tamaño del tipo
- Los punteros dobles (`**p`) son raros pero aparecen en callbacks y manipulación dinámica

---

## Próximo Paso

Una vez domines estos conceptos, puedes:

1. Analizar funciones que reciben estructuras
2. Seguir flujos de datos a través de múltiples funciones
3. Identificar modificaciones in-place a través de punteros
4. Reconstruir la lógica de programas complejos

**Practica con los ejercicios del curso para consolidar estos conceptos.** Son fundamentales para cualquier reversing profesional.
