# Clases I: Definiciones y Conceptos de POO

## IntroducciÃ³n

Hasta ahora hemos visto principalmente caracterÃ­sticas de C++ que tambiÃ©n existen en C.

 A partir de este capÃ­tulo, entramos en **el corazÃ³n de C++**: las **clases** y la **ProgramaciÃ³n Orientada a Objetos (POO)**.

**Cambio de paradigma:** La forma de pensar y estructurar programas cambia completamente. En lugar de separar datos y funciones, ahora los **agrupamos en entidades llamadas objetos**.

---

## Paradigma de ProgramaciÃ³n

### ProgramaciÃ³n Estructurada (C tradicional)

```c
// Datos separados
struct Punto {
    int x;
    int y;
};

// Funciones separadas
void mover_punto(struct Punto* p, int dx, int dy) {
    p->x += dx;
    p->y += dy;
}

int main() {
    struct Punto p = {0, 0};
    mover_punto(&p, 10, 20);  // FunciÃ³n externa
}
```

**CaracterÃ­sticas:**
- Datos y funciones estÃ¡n **separados**
- Las funciones operan **sobre** los datos
- Los datos son **pasivos**

### ProgramaciÃ³n Orientada a Objetos (C++)

```cpp
// Datos y funciones juntos
class Punto {
    int x;
    int y;
public:
    void mover(int dx, int dy) {
        x += dx;
        y += dy;
    }
};

int main() {
    Punto p;
    p.mover(10, 20);  // MÃ©todo del objeto
}
```

**CaracterÃ­sticas:**
- Datos y funciones estÃ¡n **agrupados** en una unidad (objeto)
- Las funciones son **parte del objeto**
- Los objetos son **activos** (tienen comportamiento)

## Conceptos Fundamentales de POO

### 1. ProgramaciÃ³n Orientada a Objetos (POO)

**DefiniciÃ³n:** Paradigma de programaciÃ³n que agrupa datos y procedimientos en una Ãºnica entidad llamada **objeto**.

**Siglas:**
- EspaÃ±ol: **POO**
- InglÃ©s: **OOP** (Object-Oriented Programming)

**Principio bÃ¡sico:** 
> "Cada programa es un objeto, que a su vez estÃ¡ formado de objetos que se relacionan entre sÃ­."

**Ventajas:**
- âœ… **EncapsulaciÃ³n**: Datos protegidos
- âœ… **Modularidad**: CÃ³digo organizado
- âœ… **ReutilizaciÃ³n**: Herencia y composiciÃ³n
- âœ… **Mantenibilidad**: Cambios localizados

**Nota importante:** La programaciÃ³n estructurada no desaparece, se **refuerza y complementa** con POO.

### 2. Objeto

**DefiniciÃ³n:** Unidad que engloba en sÃ­ misma:
- **Datos** (atributos, propiedades, campos)
- **Procedimientos** (funciones, mÃ©todos)

**AnalogÃ­a del mundo real:**

```
Objeto: AutomÃ³vil
â”œâ”€â”€ Datos:
â”‚   â”œâ”€â”€ marca: "Toyota"
â”‚   â”œâ”€â”€ modelo: "Corolla"
â”‚   â”œâ”€â”€ velocidad: 80 km/h
â”‚   â””â”€â”€ combustible: 45 litros
â””â”€â”€ MÃ©todos:
    â”œâ”€â”€ acelerar()
    â”œâ”€â”€ frenar()
    â”œâ”€â”€ girar()
    â””â”€â”€ abastecer()
```

**Ejemplo en C++:**

```cpp
class Automovil {
    // Datos (privados)
    string marca;
    string modelo;
    int velocidad;
    float combustible;
    
public:
    // MÃ©todos (pÃºblicos)
    void acelerar(int incremento) {
        velocidad += incremento;
    }
    
    void frenar(int decremento) {
        velocidad -= decremento;
    }
    
    void abastecer(float litros) {
        combustible += litros;
    }
};
```

**ComparaciÃ³n:**

| ProgramaciÃ³n Tradicional | POO |
|--------------------------|-----|
| Datos y funciones separados | Datos y funciones juntos |
| `struct` + funciones externas | `class` con mÃ©todos |
| Datos expuestos | Datos protegidos (encapsulaciÃ³n) |

### 3. Clase

**DefiniciÃ³n:** PatrÃ³n o plantilla para crear objetos.

**AnalogÃ­a:** 
- **Clase** = Plano de una casa
- **Objeto** = Casa construida segÃºn el plano

```cpp
// Clase: el plano
class Casa {
    int habitaciones;
    float area;
public:
    void construir();
};

// Objetos: casas construidas segÃºn el plano
Casa casa1;  // Instancia 1
Casa casa2;  // Instancia 2
Casa casa3;  // Instancia 3
```

**RelaciÃ³n Clase-Objeto:**

```
         Clase Perro
              â”‚
              â”‚ (es el patrÃ³n para)
              â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚         â”‚         â”‚
  Objeto    Objeto    Objeto
  perro1    perro2    perro3
  (Firulais)(Rex)    (Max)
```

**Diferencia clave:**

| Clase | Objeto |
|-------|--------|
| DeclaraciÃ³n / Plantilla | Instancia / Ejemplar |
| No ocupa memoria (solo definiciÃ³n) | Ocupa memoria |
| No puede recibir mensajes | Puede recibir mensajes |
| Define estructura y comportamiento | Tiene estado y comportamiento |

**Ejemplo:**

```cpp
// CLASE: definiciÃ³n, no es un objeto
class Rectangulo {
    int ancho;
    int alto;
public:
    int area() { return ancho * alto; }
};

// OBJETOS: instancias de la clase
Rectangulo r1;  // Objeto 1 en memoria
Rectangulo r2;  // Objeto 2 en memoria
Rectangulo r3;  // Objeto 3 en memoria

// Cada objeto tiene su propia copia de los datos
// Pero comparten la misma definiciÃ³n de mÃ©todos
```

### 4. MÃ©todo

**DefiniciÃ³n:** FunciÃ³n o procedimiento que pertenece a un objeto/clase.

**En C++:** Un mÃ©todo es simplemente una **funciÃ³n miembro** de una clase.

**TerminologÃ­a:**

| Contexto | TÃ©rmino |
|----------|---------|
| POO general | **MÃ©todo** |
| C++ tÃ©cnico | **FunciÃ³n miembro** |
| ConversaciÃ³n | Ambos son vÃ¡lidos |

**Ejemplo:**

```cpp
class Contador {
    int valor;
    
public:
    // MÃ©todos
    void incrementar() {    // MÃ©todo 1
        valor++;
    }
    
    void decrementar() {    // MÃ©todo 2
        valor--;
    }
    
    int obtener() {         // MÃ©todo 3
        return valor;
    }
};

int main() {
    Contador c;
    c.incrementar();  // Llamada a mÃ©todo
    c.incrementar();
    c.decrementar();
    int v = c.obtener();
}
```

**CaracterÃ­sticas:**
- Operan sobre los **datos del objeto**
- Tienen acceso a los **miembros privados**
- Pueden modificar el **estado interno** del objeto

### 5. Mensaje

**DefiniciÃ³n:** Modo en que se comunican e interrelacionan los objetos entre sÃ­.

**En C++:** Un mensaje es una **llamada a un mÃ©todo** de un objeto.

**AnalogÃ­a:**
```
Objeto Persona                  Objeto Perro
     â”‚                               â”‚
     â”‚ Mensaje: "ladra()"            â”‚
     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
     â”‚                               â”‚
     â”‚                          [Ejecuta mÃ©todo]
     â”‚                               â”‚
     â”‚     Respuesta: "Guau!"        â”‚
     â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
```

**Ejemplo en cÃ³digo:**

```cpp
class Calculadora {
    int resultado;
public:
    void sumar(int a, int b) {
        resultado = a + b;
    }
    
    int obtener_resultado() {
        return resultado;
    }
};

int main() {
    Calculadora calc;
    
    // Enviar mensaje "sumar" al objeto calc
    calc.sumar(5, 3);
    
    // Enviar mensaje "obtener_resultado"
    int res = calc.obtener_resultado();
    
    cout << res << endl;  // Output: 8
}
```

**Paso a paso:**
1. `calc.sumar(5, 3)` â†’ Enviamos mensaje "sumar" con parÃ¡metros 5 y 3
2. El objeto `calc` **procesa** el mensaje ejecutando su mÃ©todo `sumar()`
3. `calc.obtener_resultado()` â†’ Enviamos mensaje "obtener_resultado"
4. El objeto responde devolviendo el valor

**ComunicaciÃ³n entre objetos:**

```cpp
class Motor {
public:
    void encender() { /* ... */ }
    void apagar() { /* ... */ }
};

class Automovil {
    Motor motor;  // Objeto Motor dentro de Automovil
public:
    void arrancar() {
        motor.encender();  // Automovil envÃ­a mensaje a Motor
    }
    
    void detener() {
        motor.apagar();    // Automovil envÃ­a mensaje a Motor
    }
};
```

### 6. Interfaz

**DefiniciÃ³n:** Parte del objeto que es **visible** para el resto de los objetos. Conjunto de mÃ©todos (y a veces datos) pÃºblicos.

**AnalogÃ­a:** La interfaz de un objeto es como los **controles de un aparato**:
- TV: botones de encender, cambiar canal, volumen â†’ Interfaz
- Circuitos internos â†’ ImplementaciÃ³n privada

**Ejemplo:**

```cpp
class CuentaBancaria {
    // PARTE PRIVADA (no es interfaz)
    double saldo;
    string numero_cuenta;
    
    // MÃ©todo privado
    bool validar_operacion(double monto) {
        return monto > 0 && saldo >= monto;
    }
    
public:
    // INTERFAZ PÃšBLICA
    void depositar(double monto) {    // âœ… Visible
        saldo += monto;
    }
    
    bool retirar(double monto) {      // âœ… Visible
        if (validar_operacion(monto)) {
            saldo -= monto;
            return true;
        }
        return false;
    }
    
    double consultar_saldo() {        // âœ… Visible
        return saldo;
    }
};

int main() {
    CuentaBancaria cuenta;
    
    // Solo podemos usar la INTERFAZ PÃšBLICA
    cuenta.depositar(1000);         // âœ… OK
    cuenta.retirar(500);            // âœ… OK
    double s = cuenta.consultar_saldo();  // âœ… OK
    
    // No podemos acceder a la parte privada
    // cuenta.saldo = 9999999;      // âŒ ERROR: privado
    // cuenta.validar_operacion(100); // âŒ ERROR: privado
}
```

**Componentes de la interfaz:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Clase                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ INTERFAZ PÃšBLICA (visible)      â”‚
â”‚ - mÃ©todos pÃºblicos              â”‚
â”‚ - datos pÃºblicos (raro)         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ IMPLEMENTACIÃ“N PRIVADA (oculta) â”‚
â”‚ - datos privados                â”‚
â”‚ - mÃ©todos privados auxiliares   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Ventajas de una buena interfaz:**
- ğŸ”’ **EncapsulaciÃ³n**: Oculta detalles internos
- ğŸ›¡ï¸ **ProtecciÃ³n**: Evita uso indebido
- ğŸ”§ **Mantenibilidad**: Puedes cambiar la implementaciÃ³n sin afectar a los usuarios
- ğŸ“– **Claridad**: Define claramente quÃ© puede hacer el objeto

### 7. Herencia

**DefiniciÃ³n:** Capacidad de crear nuevas clases basÃ¡ndose en clases existentes, aprovechando datos y mÃ©todos, descartando otros y aÃ±adiendo nuevos.

**TerminologÃ­a:**
- **C++ tÃ©cnico:** DerivaciÃ³n de clases
- **POO general:** Herencia

**AnalogÃ­a biolÃ³gica:**

```
        Animal (clase base)
           â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”
    â”‚             â”‚
MamÃ­fero      Reptil
    â”‚             â”‚
  â”Œâ”€â”´â”€â”         â”Œâ”€â”´â”€â”
  â”‚   â”‚         â”‚   â”‚
Perro Gato  Serpiente Lagarto
```

**Ejemplo en C++:**

```cpp
// CLASE BASE
class Vehiculo {
protected:
    int velocidad;
    string marca;
    
public:
    void acelerar(int v) {
        velocidad += v;
    }
    
    void frenar(int v) {
        velocidad -= v;
    }
};

// CLASE DERIVADA 1
class Automovil : public Vehiculo {
    int num_puertas;
    
public:
    void abrir_maletero() {
        // MÃ©todo especÃ­fico de Automovil
    }
    
    // Hereda: acelerar(), frenar(), velocidad, marca
};

// CLASE DERIVADA 2
class Motocicleta : public Vehiculo {
    bool tiene_sidecar;
    
public:
    void hacer_caballito() {
        // MÃ©todo especÃ­fico de Motocicleta
    }
    
    // Hereda: acelerar(), frenar(), velocidad, marca
};
```

**Uso:**

```cpp
int main() {
    Automovil coche;
    coche.acelerar(50);     // âœ… Heredado de Vehiculo
    coche.abrir_maletero(); // âœ… Propio de Automovil
    
    Motocicleta moto;
    moto.acelerar(80);      // âœ… Heredado de Vehiculo
    moto.hacer_caballito(); // âœ… Propio de Motocicleta
}
```

**Conceptos clave:**

| TÃ©rmino | Significado |
|---------|-------------|
| **Clase base** | Clase de la que se hereda (Vehiculo) |
| **Clase derivada** | Clase que hereda (Automovil, Motocicleta) |
| **Heredar** | Recibir caracterÃ­sticas de la clase base |
| **Sobrescribir** | Redefinir un mÃ©todo heredado |
| **Extender** | AÃ±adir nuevos mÃ©todos/datos |

**Ventajas:**
- â™»ï¸ **ReutilizaciÃ³n**: No duplicar cÃ³digo
- ğŸ¯ **EspecializaciÃ³n**: AÃ±adir funcionalidad especÃ­fica
- ğŸ”„ **Mantenibilidad**: Cambios en la base afectan a todas las derivadas
- ğŸ“ **Estructura lÃ³gica**: Refleja relaciones del mundo real

**Ejemplo mÃ¡s completo:**

```cpp
class Figura {
protected:
    int x, y;  // PosiciÃ³n
    
public:
    void mover(int dx, int dy) {
        x += dx;
        y += dy;
    }
    
    virtual double area() = 0;  // MÃ©todo abstracto
};

class Rectangulo : public Figura {
    int ancho, alto;
    
public:
    double area() override {
        return ancho * alto;
    }
};

class Circulo : public Figura {
    double radio;
    
public:
    double area() override {
        return 3.14159 * radio * radio;
    }
};
```

**Herencia mÃºltiple:**

```cpp
class Anfibio : public Animal, public Acuatico {
    // Hereda de DOS clases base
};
```

### 8. JerarquÃ­a

**DefiniciÃ³n:** Orden de subordinaciÃ³n en un sistema de clases.

**CaracterÃ­sticas:**
- Herencia en **un solo sentido**: de base a derivada
- Forma estructuras de **Ã¡rbol**
- Siempre se puede retroceder a la(s) clase(s) base

**Ejemplo de jerarquÃ­a:**

```
               Ser Vivo
                  â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                   â”‚
    Vertebrado          Invertebrado
        â”‚
    â”Œâ”€â”€â”€â”´â”€â”€â”€â”
    â”‚       â”‚
MamÃ­fero   Reptil
    â”‚
  â”Œâ”€â”´â”€â”
  â”‚   â”‚
Felino Canino
  â”‚     â”‚
â”Œâ”€â”´â”€â” â”Œâ”€â”´â”€â”
â”‚   â”‚ â”‚   â”‚
Gato LeÃ³n Perro Lobo
```

**En cÃ³digo:**

```cpp
class SerVivo {
    bool esta_vivo;
public:
    virtual void respirar() = 0;
};

class Vertebrado : public SerVivo {
protected:
    int num_vertebras;
public:
    void respirar() override { /* ... */ }
};

class Mamifero : public Vertebrado {
protected:
    bool tiene_pelo;
public:
    void amamantar() { /* ... */ }
};

class Felino : public Mamifero {
protected:
    bool tiene_garras;
public:
    void cazar() { /* ... */ }
};

class Gato : public Felino {
public:
    void maullar() { cout << "Miau!" << endl; }
    
    // Hereda TODO de la jerarquÃ­a:
    // - esta_vivo (de SerVivo)
    // - num_vertebras (de Vertebrado)
    // - tiene_pelo (de Mamifero)
    // - tiene_garras (de Felino)
    // + mÃ©todos de todas las clases
};
```

**Niveles jerÃ¡rquicos:**

```cpp
Gato miGato;

// Todos estos son vÃ¡lidos:
Gato* p1 = &miGato;        // Como Gato
Felino* p2 = &miGato;      // Como Felino
Mamifero* p3 = &miGato;    // Como Mamifero
Vertebrado* p4 = &miGato;  // Como Vertebrado
SerVivo* p5 = &miGato;     // Como SerVivo
```

**Importancia:**
- Permite **polimorfismo** (siguiente concepto)
- Facilita **diseÃ±o modular**
- Refleja **relaciones naturales**

### 9. Polimorfismo

**DefiniciÃ³n literal:** "Cualidad de lo que tiene o puede tener distintas formas"

**DefiniciÃ³n POO:** Propiedad segÃºn la cual un mismo objeto puede considerarse como perteneciente a distintas clases.

**Idea bÃ¡sica:** Un objeto de una clase derivada puede tratarse como si fuera de cualquier clase de su jerarquÃ­a.

**Ejemplo conceptual:**

```
JerarquÃ­a: SerVivo â†’ Vertebrado â†’ MamÃ­fero â†’ Felino â†’ Gato

Un objeto "Gato" puede tratarse como:
- Gato       (su clase real)
- Felino     (puede actuar como felino genÃ©rico)
- MamÃ­fero   (puede actuar como mamÃ­fero genÃ©rico)
- Vertebrado (puede actuar como vertebrado genÃ©rico)
- SerVivo    (puede actuar como ser vivo genÃ©rico)
```

**Ejemplo prÃ¡ctico:**

```cpp
class Felino {
public:
    virtual void hacer_sonido() = 0;  // MÃ©todo abstracto
    virtual void cazar() { /* ... */ }
};

class Gato : public Felino {
public:
    void hacer_sonido() override {
        cout << "Miau!" << endl;
    }
};

class Leon : public Felino {
public:
    void hacer_sonido() override {
        cout << "Roar!" << endl;
    }
};

class Tigre : public Felino {
public:
    void hacer_sonido() override {
        cout << "Grrr!" << endl;
    }
};

// POLIMORFISMO EN ACCIÃ“N
void alimentar_felino(Felino* f) {  // Acepta CUALQUIER felino
    f->hacer_sonido();
    f->cazar();
}

int main() {
    Gato g;
    Leon l;
    Tigre t;
    
    // Todos se pueden tratar como "Felino"
    alimentar_felino(&g);  // âœ… Gato como Felino
    alimentar_felino(&l);  // âœ… Leon como Felino
    alimentar_felino(&t);  // âœ… Tigre como Felino
}
```

**Array polimÃ³rfico:**

```cpp
// Almacenar diferentes tipos en un array de punteros a la clase base
Felino* felinos[4];
felinos[0] = new Gato();
felinos[1] = new Leon();
felinos[2] = new Tigre();
felinos[3] = new Gato();

// Iterar sobre todos, sin importar su tipo real
for (int i = 0; i < 4; i++) {
    felinos[i]->hacer_sonido();  // Cada uno hace su sonido
}
```

**Output:**
```
Miau!
Roar!
Grrr!
Miau!
```

**Tipos de polimorfismo:**

| Tipo | CuÃ¡ndo se resuelve | Ejemplo |
|------|-------------------|---------|
| **EstÃ¡tico** | CompilaciÃ³n | Sobrecarga de funciones |
| **DinÃ¡mico** | EjecuciÃ³n | Funciones virtuales |

**Ejemplo de polimorfismo estÃ¡tico (sobrecarga):**

```cpp
class Calculadora {
public:
    int sumar(int a, int b) {
        return a + b;
    }
    
    double sumar(double a, double b) {  // Mismo nombre, diferente tipo
        return a + b;
    }
    
    int sumar(int a, int b, int c) {    // Mismo nombre, diferente cantidad
        return a + b + c;
    }
};

Calculadora calc;
calc.sumar(2, 3);        // Llama a sumar(int, int)
calc.sumar(2.5, 3.7);    // Llama a sumar(double, double)
calc.sumar(1, 2, 3);     // Llama a sumar(int, int, int)
```

**Ventajas del polimorfismo:**
- ğŸ”„ **Flexibilidad**: Mismo cÃ³digo funciona con diferentes tipos
- ğŸ“¦ **Extensibilidad**: FÃ¡cil agregar nuevos tipos
- ğŸ¯ **AbstracciÃ³n**: Trabajar con conceptos genÃ©ricos
- ğŸ§© **CÃ³digo limpio**: Menos condicionales (`if`/`switch`)

## ComparaciÃ³n Final: Estructural vs POO

### Programa Estructural

```c
// Datos
struct Cuenta {
    double saldo;
    char titular[50];
};

// Funciones separadas
void depositar(struct Cuenta* c, double monto) {
    c->saldo += monto;
}

double consultar_saldo(struct Cuenta* c) {
    return c->saldo;
}

// Uso
struct Cuenta c1;
depositar(&c1, 1000);
double s = consultar_saldo(&c1);
```

**Problemas:**
- âŒ Datos expuestos: cualquiera puede hacer `c1.saldo = -9999`
- âŒ Funciones dispersas: no hay agrupaciÃ³n lÃ³gica
- âŒ Sin protecciÃ³n: no hay encapsulaciÃ³n

### Programa POO

```cpp
// Clase: datos + funciones juntos
class Cuenta {
    double saldo;      // Privado
    string titular;    // Privado
    
public:
    void depositar(double monto) {
        if (monto > 0) {
            saldo += monto;
        }
    }
    
    double consultar_saldo() {
        return saldo;
    }
};

// Uso
Cuenta c1;
c1.depositar(1000);
double s = c1.consultar_saldo();
// c1.saldo = -9999;  // âŒ ERROR: protegido
```

**Ventajas:**
- âœ… Datos protegidos: solo acceso controlado
- âœ… Funciones agrupadas: todo relacionado junto
- âœ… EncapsulaciÃ³n: implementaciÃ³n oculta

## Resumen de Conceptos

| Concepto | DefiniciÃ³n Breve | AnalogÃ­a |
|----------|------------------|----------|
| **POO** | Paradigma que agrupa datos y funciones | Organizar por objetos del mundo real |
| **Objeto** | Instancia de una clase con estado y comportamiento | Un coche especÃ­fico (no el plano) |
| **Clase** | Plantilla para crear objetos | Plano de una casa |
| **MÃ©todo** | FunciÃ³n de un objeto | BotÃ³n de un control remoto |
| **Mensaje** | Llamada a un mÃ©todo | Presionar un botÃ³n |
| **Interfaz** | Parte pÃºblica de una clase | Controles visibles de un aparato |
| **Herencia** | Crear clases basadas en otras | Hijo hereda caracterÃ­sticas de padres |
| **JerarquÃ­a** | Estructura de Ã¡rbol de clases | Ãrbol genealÃ³gico |
| **Polimorfismo** | Mismo objeto, mÃºltiples formas | Actor que interpreta varios roles |

## Pilares de la POO

### 1. EncapsulaciÃ³n ğŸ”’

```cpp
class Ejemplo {
private:    // Oculto
    int dato;
public:     // Visible
    void set_dato(int d) { dato = d; }
    int get_dato() { return dato; }
};
```

### 2. Herencia ğŸ§¬

```cpp
class Base {
    // ...
};

class Derivada : public Base {
    // Hereda de Base + aÃ±ade nuevas caracterÃ­sticas
};
```

### 3. Polimorfismo ğŸ­

```cpp
Base* ptr = new Derivada();
ptr->metodo();  // Ejecuta versiÃ³n de Derivada
```

### 4. AbstracciÃ³n ğŸ¨

```cpp
class Forma {  // Concepto abstracto
public:
    virtual double area() = 0;  // MÃ©todo puro virtual
};
```

---

## Referencias

- ProgramaciÃ³n Orientada a Objetos (Grady Booch)
- The C++ Programming Language (Bjarne Stroustrup)
- Effective C++ (Scott Meyers)
- Object-Oriented Software Construction (Bertrand Meyer)
