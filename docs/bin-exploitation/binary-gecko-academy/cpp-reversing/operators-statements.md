### Operadores y sentencias

#### Sentencias basicas
- Expresion de asignacion: `variable = expresion;`.
- Entrada/salida basica: `#include <iostream>` y `using namespace std;`.  
  - Salida: `cout << "texto" << variable;` concatena sin salto de linea.  
  - Entrada: `cin >> variable;` guarda lo tecleado.  
  - `endl` fuerza salto de linea; `cin.get()` puede limpiar caracteres pendientes en el buffer.  
  - Para caracteres con acento puede usarse `#include <locale.h>` y `setlocale(LC_ALL, "spanish");`, aunque lo ideal es usar Unicode.

#### Bucles
- `while (condicion) { ... }`: ejecuta mientras la condicion sea verdadera.
- `do { ... } while (condicion);`: ejecuta al menos una vez y luego reevalua.
- `for (int i = 0; i < limite; i++) { ... }`: inicializacion, condicion y actualizacion en una sola linea.

#### Seleccion y saltos
- `switch (expr) { case 'a': ... break; default: ... }`: dirige el flujo segun el valor; `default` si no coincide ningun `case`.
- `break` sale del bucle o switch; `continue` salta al siguiente ciclo; `goto` salta a una etiqueta (usar con cuidado); `return` finaliza una funcion y puede devolver valor.

#### Ejemplo 1: multiples de 3 con `for`
```cpp
for (int i = 1; i <= 20; i++) {
    cout << i;
    if (i % 3 == 0)
        cout << " es multiplo de 3";
    else
        cout << " no es multiplo de 3";
    cout << endl;
}
```
- En asm: el compilador usa `idiv` con divisor 3; el resto queda en `edx` y se prueba con `test edx, edx`. Si es cero se toma como multiplo.
- `cdq` se ejecuta antes de `idiv` para extender el signo y evitar fallos en divisiones con signo.
- En IDA: habilitar nombres demanglados y limpiar el grafo ayuda a leer; el decompilado (F5) puede sincronizarse para ver que cada llamada a `cout` ocupa varias instrucciones.

#### Ejemplo 2: funcion auxiliar `multiplo_de_tres`
```cpp
bool multiplo_de_tres(int n) {
    return (n % 3) == 0;
}

int main() {
    int i = 1;
    while (i <= 20) {
        cout << i;
        if (multiplo_de_tres(i))
            cout << " es multiplo de 3";
        else
            cout << " no es multiplo de 3";
        cout << endl;
        i++;
    }
}
```
- El valor `bool` regresa en `al`; el main compara ese byte para decidir que mensaje imprimir.
- El bucle `while` y un `for` generan estructuras de control muy similares en asm; al desensamblar se ven como el mismo loop con comparacion y salto condicional.

#### Notas de reversing y stack
- Al entrar a una funcion el `call` deja el return address en el stack, desalineando `rsp`; el compilador resta (ej. `sub rsp, 38h`) para reservar shadow space (4 qwords) + variables locales + padding.
- El padding extra asegura que, tras el ajuste, `rsp` quede alineado a 16 bytes antes de cualquier `call` interno; algunas API de Windows fallan si no se respeta.
- Shadow space: los 4 primeros qwords debajo del return address pueden almacenar temporalmente los cuatro primeros argumentos por convencion de Windows x64.
- IDA permite ver el cuadro de stack estatico: return address, shadow space, variables locales y padding para alineacion.
