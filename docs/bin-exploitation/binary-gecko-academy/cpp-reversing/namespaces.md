# Espacios con Nombre (Namespaces)

## Introducci√≥n

Un **espacio con nombre** (namespace) es una zona separada donde se pueden declarar y definir:
- Variables
- Funciones
- Clases
- Estructuras
- Cualquier identificador de tipo

**Prop√≥sito principal:** Evitar conflictos de nombres entre diferentes bibliotecas o partes de un programa.

### Problema sin Namespaces

```cpp
// biblioteca1.h
class Conjunto { /* ... */ };

// biblioteca2.h
class Conjunto { /* ... */ };  // ‚ùå ERROR: redefinici√≥n

// main.cpp
#include "biblioteca1.h"
#include "biblioteca2.h"  // Conflicto de nombres
```

### Soluci√≥n con Namespaces

```cpp
// biblioteca1.h
namespace matematicas {
    class Conjunto { /* ... */ };
}

// biblioteca2.h
namespace graficos {
    class Conjunto { /* ... */ };
}

// main.cpp
matematicas::Conjunto c1;  // ‚úÖ OK
graficos::Conjunto c2;     // ‚úÖ OK
```

## Espacio Global

**Antes de usar namespaces**, todas las declaraciones estaban en el **espacio global**:

```cpp
int x;              // Variable global
void funcion();     // Funci√≥n global
struct Punto {};    // Estructura global
```

**Con namespaces**, podemos organizar el c√≥digo:

```cpp
namespace proyecto {
    int x;
    void funcion();
    struct Punto {};
}
```

## Declaraci√≥n y Definici√≥n

### Sintaxis B√°sica

```cpp
namespace <identificador> {
    // Declaraciones y definiciones
}
```

### Ejemplo: Puntos 2D vs 3D

```cpp
// Fichero: puntos.h

namespace espacio_2D {
    struct Punto {
        int x;
        int y;
    };
}

namespace espacio_3D {
    struct Punto {
        int x;
        int y;
        int z;
    };
}
```

**Dos estructuras con el mismo nombre (`Punto`), pero en espacios diferentes.**

## Formas de Uso

### 1. Acceso Completo (Sin Activar)

```cpp
#include "puntos.h"

int main() {
    espacio_2D::Punto p1;  // Acceso completo con ::
    espacio_3D::Punto p2;
    
    p1.x = 10;
    p2.x = 20;
}
```

**Operador `::`**: Especificador de √°mbito (scope resolution operator)

### 2. Forma Directiva: `using namespace`

```cpp
using namespace <identificador>;
```

**Activa todo el espacio** para uso por defecto:

```cpp
#include "puntos.h"

using namespace espacio_2D;  // Activar espacio completo

int main() {
    Punto p1;              // ‚úÖ espacio_2D::Punto (activo)
    espacio_3D::Punto p2;  // Necesita especificar (no activo)
}
```

**Ejemplo con `std`:**

```cpp
#include <iostream>

using namespace std;  // Activar espacio std

int main() {
    cout << "Hola" << endl;  // ‚úÖ Sin std:: adelante
    cin.get();
}
```

**Sin `using namespace std`:**

```cpp
#include <iostream>

int main() {
    std::cout << "Hola" << std::endl;  // Necesita std::
    std::cin.get();
}
```

### 3. Forma Declarativa: `using` Individual

```cpp
using <nombre_espacio>::<identificador>;
```

**Activa solo un identificador espec√≠fico**:

```cpp
#include "puntos.h"

using espacio_3D::Punto;  // Solo activa Punto de espacio_3D

int main() {
    Punto p2;              // ‚úÖ espacio_3D::Punto (activo)
    espacio_2D::Punto p1;  // Necesita especificar
}
```

**Ejemplo con `std`:**

```cpp
#include <iostream>

using std::cout;  // Solo activar cout
using std::endl;

int main() {
    cout << "Hola" << endl;  // ‚úÖ Estos est√°n activos
    std::cin.get();          // ‚ùå cin necesita std::
}
```

### Comparaci√≥n de Formas

| Forma | Sintaxis | Activa | Ejemplo |
|-------|----------|--------|---------|
| **Completa** | `espacio::item` | Nada | `std::cout << "Hi"` |
| **Directiva** | `using namespace espacio;` | Todo el espacio | `cout << "Hi"` |
| **Declarativa** | `using espacio::item;` | Solo ese item | `cout << "Hi"` pero `std::cin.get()` |

## Ejemplo Completo 1: Dos Namespaces

### C√≥digo Fuente

```cpp
#include <iostream>

namespace uno {
    int x;
}

namespace dos {
    int x;
}

using namespace uno;  // Activar espacio "uno"

int main() {
    x = 10;         // uno::x (activo)
    dos::x = 30;    // dos::x (necesita especificar)
    
    std::cout << x << ", " << dos::x << std::endl;
    std::cin.get();
    return 0;
}
```

**Output:**
```
10, 30
```

### An√°lisis a Bajo Nivel

#### Ensamblador

```asm
_DATA SEGMENT
int uno::x DD 00H        ; Variable del namespace "uno"
int dos::x DD 00H        ; Variable del namespace "dos"
_DATA ENDS

main:
    ; x = 10;  (uno::x)
    mov     DWORD PTR uno::x, 10
    
    ; dos::x = 30;
    mov     DWORD PTR dos::x, 30
    
    ; Imprimir valores
    mov     edx, DWORD PTR uno::x
    mov     rcx, QWORD PTR std::cout
    call    std::basic_ostream::operator<<
    
    mov     edx, DWORD PTR dos::x
    mov     rcx, rax
    call    std::basic_ostream::operator<<
```

#### Observaciones Clave

**A bajo nivel:**
1. **No existe "activado" vs "no activado"**
2. **Todas las variables llevan el namespace como prefijo**: `uno::x`, `dos::x`
3. **El compilador traduce todo a nombres completos**
4. **IDA muestra los nombres con el namespace incluido**

**Conclusi√≥n:** `using namespace` es solo **sintaxis para el programador**. El compilador siempre usa nombres completos internamente.

## Espacios Anidados

### Concepto

Los namespaces pueden contener otros namespaces:

```cpp
namespace nivel1 {
    int x;
    
    namespace nivel2 {
        int x;
        
        namespace nivel3 {
            int x;
        }
    }
}
```

### Ejemplo Completo

```cpp
#include <iostream>

namespace uno {
    int x;
    
    namespace dos {
        int x;
        
        namespace tres {
            int x;
        }
    }
}

using std::cout;
using std::endl;
using uno::x;  // Solo activar uno::x

int main() {
    x = 10;                  // uno::x (activo)
    uno::dos::x = 30;        // Necesita ruta completa
    uno::dos::tres::x = 50;  // Necesita ruta completa
    
    cout << x << ", " 
         << uno::dos::x << ", " 
         << uno::dos::tres::x << endl;
    
    std::cin.get();
    return 0;
}
```

**Output:**
```
10, 30, 50
```

### An√°lisis a Bajo Nivel

```asm
_DATA SEGMENT
int uno::x DD 00H              ; Primer nivel
int uno::dos::x DD 00H         ; Segundo nivel
int uno::dos::tres::x DD 00H   ; Tercer nivel
_DATA ENDS

main:
    ; x = 10;
    mov     DWORD PTR uno::x, 10
    
    ; uno::dos::x = 30;
    mov     DWORD PTR uno::dos::x, 30
    
    ; uno::dos::tres::x = 50;
    mov     DWORD PTR uno::dos::tres::x, 50
```

**Observaci√≥n:** Todos los niveles se aplanan a nombres √∫nicos con `::` como separador.

## Espacios An√≥nimos

### Concepto

Namespaces **sin nombre**:

```cpp
namespace {
    int x = 10;  // Variable interna al archivo
}
```

**Prop√≥sito:** Crear identificadores accesibles **solo en el archivo actual**.

### Ejemplo

```cpp
namespace Nombre {
    int f();
    char s;
    void g(int);
}

namespace {
    int x = 10;  // Solo accesible desde aqu√≠ hasta el fin del archivo
}

namespace Nombre {
    int f() {
        return x;  // ‚úÖ Puede acceder a x
    }
}
```

**Caracter√≠sticas:**
- No necesita especificar nombre para acceder
- Variables/funciones son **internas al archivo**
- Alternativa moderna a `static` global

### Equivalencia con `static`

**Forma antigua:**
```cpp
static int x = 10;  // Variable interna al archivo
```

**Forma moderna (C++):**
```cpp
namespace {
    int x = 10;  // Preferido en C++ moderno
}
```

**Nota:** La especificaci√≥n de C++ recomienda usar namespaces an√≥nimos en lugar de `static` para evitar confusi√≥n con otros usos de `static`.

## Namespace Inline

### Concepto

```cpp
namespace uno {
    int x;
    
    inline namespace dos {
        int i;  // Embebido en "uno"
    }
}
```

**Efecto:** El contenido del namespace `inline` se **"aplana"** dentro del namespace padre.

### Ejemplo

```cpp
#include <iostream>

namespace uno {
    int x;
    
    inline namespace dos {  // inline: contenido embebido en "uno"
        int i;
    }
}

using namespace uno;

int main() {
    x = 10;   // uno::x
    i = 30;   // uno::i (no necesita uno::dos::i)
    
    std::cout << x << ", " << i << std::endl;
    return 0;
}
```

**Sin `inline`:**
```cpp
uno::dos::i = 30;  // Necesitar√≠a ruta completa
```

**Con `inline`:**
```cpp
uno::i = 30;  // Acceso directo como si estuviera en "uno"
```

### Namespace Inline An√≥nimo

```cpp
namespace uno {
    int x;
    
    inline namespace {  // Sin nombre
        int i;
    }
}

int main() {
    uno::x = 10;
    uno::i = 30;  // ‚úÖ Accesible directamente desde "uno"
}
```

**No es necesario darle nombre** porque est√° embebido en el padre.

### A Bajo Nivel

```asm
_DATA SEGMENT
int uno::x DD 00H
int uno::i DD 00H    ; "dos" desaparece, i est√° directamente en "uno"
_DATA ENDS
```

**El namespace inline desaparece** en el c√≥digo compilado.

## Alias de Namespaces

### Sintaxis

```cpp
namespace <alias> = <nombre_espacio>;
```

### Ejemplo

```cpp
namespace nombredemasiadolargoycomplicado {
    int x;
    void funcion();
}

namespace ndlyc = nombredemasiadolargoycomplicado;  // Alias

int main() {
    ndlyc::x = 10;          // ‚úÖ M√°s corto
    ndlyc::funcion();
}
```

**Uso com√∫n:** Simplificar nombres largos o crear shortcuts.

## Namespaces en M√∫ltiples Archivos

### Concepto

Un namespace puede **extenderse a trav√©s de m√∫ltiples archivos**:

**archivo1.cpp:**
```cpp
namespace proyecto {
    int x = 10;
    void funcion1() { /* ... */ }
}
```

**archivo2.cpp:**
```cpp
namespace proyecto {  // Mismo namespace
    void funcion2() { /* ... */ }
}
```

**main.cpp:**
```cpp
namespace proyecto {  // Se extiende m√°s
    void funcion3() { /* ... */ }
}

int main() {
    proyecto::x = 5;       // De archivo1.cpp
    proyecto::funcion1();  // De archivo1.cpp
    proyecto::funcion2();  // De archivo2.cpp
    proyecto::funcion3();  // De este archivo
}
```

**El namespace `std` funciona as√≠**: se define en todos los headers est√°ndar.

## An√°lisis para Reversing

### Reglas Generales

1. **`using namespace` no existe a bajo nivel**
   - Todo se convierte a nombres completos
   
2. **El namespace aparece como prefijo**
   ```cpp
   namespace espacio { int x; }
   ```
   ```asm
   int espacio::x DD 00H
   ```

3. **No hay diferencia entre "activo" e "inactivo"**
   - IDA muestra siempre el nombre completo
   
4. **Funciones tambi√©n llevan el namespace**
   ```cpp
   namespace math { void calc(); }
   ```
   ```asm
   call math::calc
   ```

### Patr√≥n de Reconocimiento

**En IDA/Ghidra:**
```
std::cout
std::operator<<
proyecto::variable
math::funcion
```

**Indica:**
- `std` ‚Üí Biblioteca est√°ndar
- `proyecto` ‚Üí Namespace personalizado
- `math` ‚Üí Posible biblioteca matem√°tica

### Ejemplo de An√°lisis

**C√≥digo:**
```cpp
namespace game {
    class Player {
        int health;
    public:
        void damage(int amount);
    };
}

void game::Player::damage(int amount) {
    health -= amount;
}

int main() {
    game::Player p;
    p.damage(10);
}
```

**Ensamblador:**
```asm
; Funci√≥n con namespace completo en el nombre
game::Player::damage:
    mov     rax, QWORD PTR [rcx]    ; this->health
    sub     eax, edx                 ; health -= amount
    mov     DWORD PTR [rcx], eax
    ret

main:
    lea     rcx, QWORD PTR p$[rsp]
    mov     edx, 10
    call    game::Player::damage    ; Nombre completo visible
```

### Diferencias con/sin `using namespace`

#### Con `using namespace`

**C√≥digo:**
```cpp
#include <iostream>
using namespace std;

int main() {
    cout << "Hi" << endl;
}
```

**Ensamblador:**
```asm
main:
    lea     rdx, OFFSET FLAT:$SG001
    mov     rcx, QWORD PTR std::cout
    call    std::operator<<          ; ‚Üê Siempre std:: en ASM
    
    lea     rdx, OFFSET FLAT:std::endl
    mov     rcx, rax
    call    std::operator<<
```

#### Sin `using namespace`

**C√≥digo:**
```cpp
#include <iostream>

int main() {
    std::cout << "Hi" << std::endl;
}
```

**Ensamblador:**
```asm
main:
    lea     rdx, OFFSET FLAT:$SG001
    mov     rcx, QWORD PTR std::cout
    call    std::operator<<          ; ‚Üê Id√©ntico al anterior
    
    lea     rdx, OFFSET FLAT:std::endl
    mov     rcx, rax
    call    std::operator<<
```

**Conclusi√≥n:** **El ensamblador es id√©ntico**. La diferencia solo existe en el c√≥digo fuente.

## Buenas Pr√°cticas

### ‚úÖ Recomendado

```cpp
// En archivos .cpp
using namespace std;  // OK en implementaci√≥n

// Uso selectivo
using std::cout;
using std::endl;

// Namespaces para organizar c√≥digo
namespace mi_proyecto {
    // Todo tu c√≥digo
}
```

### ‚ùå No Recomendado

```cpp
// En archivos .h (headers)
using namespace std;  // ‚ùå Contamina a todos los que incluyan

// Namespace sin prop√≥sito
namespace n { int x; }  // ‚ùå Nombre poco descriptivo
```

### üîç En Headers

**Preferir forma completa:**
```cpp
// archivo.h
#include <iostream>

void imprimir() {
    std::cout << "Mensaje" << std::endl;  // ‚úÖ Forma completa
}
```

**Evitar `using` en headers:**
```cpp
// archivo.h
using namespace std;  // ‚ùå Forzar√° a todos los que incluyan a usar "std"
```

## Resoluci√≥n de Conflictos

### Problema

```cpp
namespace lib1 { void funcion(); }
namespace lib2 { void funcion(); }

using namespace lib1;
using namespace lib2;

int main() {
    funcion();  // ‚ùå ERROR: ambiguo
}
```

**Error:**
```
error: call to 'funcion' is ambiguous
```

### Soluci√≥n 1: Especificar Namespace

```cpp
int main() {
    lib1::funcion();  // ‚úÖ Expl√≠cito
    lib2::funcion();
}
```

### Soluci√≥n 2: Alias

```cpp
namespace l1 = lib1;
namespace l2 = lib2;

int main() {
    l1::funcion();
    l2::funcion();
}
```

### Soluci√≥n 3: `using` Selectivo

```cpp
using lib1::funcion;  // Solo activar esta

int main() {
    funcion();         // lib1::funcion
    lib2::funcion();   // Especificar la otra
}
```

## Namespaces y Clases

### Clase dentro de Namespace

```cpp
namespace matematicas {
    class Vector {
        double x, y;
    public:
        Vector(double x, double y);
        double modulo();
    };
}

// Definici√≥n fuera
matematicas::Vector::Vector(double x, double y) 
    : x(x), y(y) {}

double matematicas::Vector::modulo() {
    return sqrt(x*x + y*y);
}
```

### Uso

```cpp
int main() {
    matematicas::Vector v(3, 4);
    cout << v.modulo() << endl;  // Output: 5
}
```

### A Bajo Nivel

```asm
; Constructor
matematicas::Vector::Vector:
    mov     QWORD PTR [rcx], rdx    ; this->x = x
    mov     QWORD PTR [rcx+8], r8   ; this->y = y
    ret

; M√©todo
matematicas::Vector::modulo:
    movsd   xmm0, QWORD PTR [rcx]      ; x
    mulsd   xmm0, xmm0                  ; x*x
    movsd   xmm1, QWORD PTR [rcx+8]    ; y
    mulsd   xmm1, xmm1                  ; y*y
    addsd   xmm0, xmm1                  ; x*x + y*y
    sqrtsd  xmm0, xmm0                  ; sqrt(...)
    ret
```

**Nombre completo:** `matematicas::Vector::modulo`

## Tabla Resumen

| Caracter√≠stica | Sintaxis | Efecto |
|----------------|----------|--------|
| **Declarar namespace** | `namespace nombre { }` | Crea espacio |
| **Activar todo** | `using namespace nombre;` | Todo accesible directamente |
| **Activar uno** | `using nombre::item;` | Solo ese item accesible |
| **Acceso completo** | `nombre::item` | Acceso expl√≠cito |
| **Anidado** | `namespace n1 { namespace n2 {} }` | Niveles: `n1::n2::item` |
| **An√≥nimo** | `namespace { }` | Interno al archivo |
| **Inline** | `inline namespace n { }` | Embebido en padre |
| **Alias** | `namespace alias = nombre;` | Nombre corto |

## Comparaci√≥n: C vs C++

### Headers Est√°ndar

| C | C++ (global) | C++ (namespace std) |
|---|--------------|---------------------|
| `stdio.h` | `stdio.h` | `cstdio` |
| `stdlib.h` | `stdlib.h` | `cstdlib` |
| `string.h` | `string.h` | `cstring` |
| `math.h` | `math.h` | `cmath` |

**Ejemplo:**
```cpp
#include <stdio.h>   // C: printf en espacio global
#include <cstdio>    // C++: std::printf

// C style (global)
printf("Hello\n");

// C++ style (namespace)
std::printf("Hello\n");
```

## Conclusi√≥n para Reversing

### Lo Visible

‚úÖ **Nombres completos con namespace**
```asm
std::cout
proyecto::funcion
math::Vector::calcular
```

‚úÖ **Variables con prefijo**
```asm
int namespace1::x
int namespace2::x
```

### Lo Invisible

‚ùå **`using namespace`** (solo sintaxis fuente)
‚ùå **Distinci√≥n activo/inactivo** (todo es expl√≠cito)
‚ùå **`inline namespace`** (se aplana)

### Enfoque Pr√°ctico

1. **Observar prefijos `namespace::`** en nombres
2. **Identificar bibliotecas** por namespace (`std`, `boost`, etc.)
3. **Reconstruir organizaci√≥n** del c√≥digo original
4. **Ignorar** si algo estaba "activo" (irrelevante en ASM)

## Palabras Reservadas

- `namespace`
- `using`
- `inline` (para namespaces inline)

## Referencias

- C++ Standard: Namespaces (ISO/IEC 14882)
- Effective C++ (Scott Meyers) - Item 57: Use namespaces to prevent name conflicts
- [cppreference.com/namespace](https://en.cppreference.com/w/cpp/language/namespace)
